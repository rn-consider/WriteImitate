Java基础学习笔记一 Java介绍
java语言概述
Java是sun公司开发的一门编程语言,目前被Oracle公司收购，编程语言就是用来编写软件的。

 Java的应用
开发QQ、迅雷程序(桌面应用软件)
淘宝、京东(互联网应用软件)
安卓应用程序
 Java的擅长
互联网：电商、P2P等等
企业级应用：ERP、CRM、BOS、OA等等
Java语言平台
JavaSE（标准版）部分,JavaSE并不能开发大型项目。
JavaEE（企业版）部分,学习完JavaEE部分就可以开发各种大型项目了。
java语言开发环境
JDK是Java开发环境，官网 http://www.oracle.com/cn/index.html

JDK的安装
傻瓜式安装，双击安装程序，然后一路next即可，安装的推荐方式：

安装路径不要有中文或者特殊符号如空格等。
所有和开发相关的软件最好安装目录统一。
当提示安装JRE时，可以选择不安装。建议还是安装上。
 验证安装是否成功，通过DOS命令，切换到JDK安装的bin目录下。比如 D:\develop\Java\jdk1.7.0_72\bin，然后分别输入javac和java，如果正常显示一些内容，说明安装成功。

配置环境变量
环境变量的作用：由于javac和java命令只能在固定的目录下才能执行，而我们写的代码如果都和javac及java命令放在相同的目录中的话，会显得很乱”，为了让Java的bin目录下的javac命令可以在任意目录下执行，就得配置环境变量。

具体安装参考：JAVA开发环境的搭建（配置JAVA开发环境）

JDK和JRE以及跨平台

JDK与JRE的关系

JDK：Java Development Kit ，Java语言的开发工具包，提供了Java语言的开发工具，它里面包含了JRE，同时也就包含了JVM（Java虚拟机）。
JRE：Java Runtime Environment，它是Java运行环境，如果你不需要开发只需要运行Java程序，那么你可以安装JRE。例如程序员开发出的程序最终卖给了用户，用户不用开发，只需要运行程序，所以用户在电脑上安装JRE即可。它包含了Java虚拟机，也就是JVM，同时还包含了Java语言运行需要的核心类库。
跨平台特性：平台指的是操作系统 （Windows，Linux，Mac）。只需在相应的平台上安装Java虚拟机，就可以运行Java程序。

使用IntelliJ IDEA打印Hello World
第一步：创建新项目


第二步：选择jdk，然后next


第三步：选择Hello World模板，然后Next
 

第四步：输入项目名称，然后Finish


第五步：运行


第六步：查看结果


Java代码的编写执行过程
源文件：编写Java源文件（我们也称之为源代码文件），它的扩展名为.java；

编译：然后通过编译器把源文件编译成字节码文件，字节码文件扩展名为.class；

运行：最后使用解释器来运行字节码文件。

CentOS7下Java8安装
1、到https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html找到jdk-8u221-linux-x64.tar.gz的下载地址，需要登录。

2、打开终端，使用 wget命令下载。比如：wget https://download.oracle.com/otn/java/jdk/8u221-b11/230deb18db3e4014bb8e3e8324f81b43/jdk-8u221-linux-x64.tar.gz?AuthParam=1569641530_05c699a00ac2afe0c0dde7cc5784e4d5

3、解压，tar -xzvf jdk-8u221-linux-x64.tar.gz?AuthParam=1569641530_05c699a00ac2afe0c0dde7cc5784e4d5

4、移动到/usr/local目录下，mv jdk-8u221-linux-x64.tar.gz?AuthParam=1569641530_05c699a00ac2afe0c0dde7cc5784e4d5 /opt/usr

5、切换到opt目录下，cd /opt/usr

6、改名为java8，mv jdk-8u221-linux-x64.tar.gz?AuthParam=1569641530_05c699a00ac2afe0c0dde7cc5784e4d5 java8

7、配置环境变量，vi /etc/profile,在文件后面追加以下代码：

JAVA_HOME=/usr/local/java8
JRE_HOME=/usr/local/java8/jre
PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib
export JAVA_HOME JRE_HOME PATH CLASSPATH

8、执行source /etc/profile命令使配置生效，到这一步就算安装完成了，使用java -version查看安装是否成功。
Java基础学习笔记二 Java基础语法
注释
注释用来解释和说明程序的文字，注释是不会被执行的.

单行注释

//这是一条单行注释 
public int i;
多行注释


/* 这是
* 一段注释，
* 它跨越了多个行
*/ 
public void f() {}
}

文档注释 


/** The first Thinking in Java example program.
* Lists system information on current machine.
* @author Bruce Eckel
* @author http://www.BruceEckel.com
* @version 1.0
*/
public class Property {
/** Sole entry point to class & application
* @param args array of string arguments
* @return No return value
* @exception exceptions No exceptions thrown
*/
public static void main(String[] args) {
System.out.println(new Date());
Properties p = System.getProperties();
p.list(System.out);
System.out.println("--- Memory Usage:");
Runtime rt = Runtime.getRuntime();
System.out.println("Total Memory = "
+ rt.totalMemory()
+ " Free Memory = "
+ rt.freeMemory());
}59
}

对于单行和多行注释，被注释的文字，不会被JVM解释执行；对于文档注释，可以被JDK提供的工具javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档；单行注释可以嵌套使用，多行注释不能嵌套使用。

关键字
是被Java语言赋予特殊含义，具有专门用途的单词，比如class，int，double均为Java已经预设好的;

组成关键字的字母全部小写 ,注意String不是关键字;

goto与const是Java中的保留字，即没有赋予特殊含义却仍被Java占用的单词;

标识符
就是给类,接口,方法,变量等起名字时使用的字符序列,组成规则只能包含下面的内容,不能有其它内容:

 英文大小写字母
数字字符
 $和_
注意事项
数字不能开头
不可以使用关键字
严格区分大小写，不限制长度
起名时，尽量见名知意
标识符中常见的命名规则
包名：多单词组成时所有字母均小写，使用.连接.比如：aaa.bbb.ccc
类名&接口名：大驼峰式。比如：AaaBbbCcc
变量名&方法名：小驼峰式。比如：aaaBbbCcc
常量名：多单词组成是所有字母均大写，使用_连接。比如：AAA_BBB_CCC
数据类型
为什么有数据类型？

Java是强类型语言，对于每一种数据都定义了明确的具体数据类型，变量必须要有明确的类型，什么类型的变量装载什么类型的数据。

数据类型的分类
基本数据类型

基本数据类型是Java语言中内置的类型，分别是整数类型、小数类型、字符类型、布尔类型。

这四类基本类型是最简单、最基础的类型。

整数(byte、short、int、long)，默认的整数类型是int类型，long类型需添加"L"后缀。
小数(float、double)、字符类型(char)，默认的浮点类型是double类型。在Java中所有没有后缀以及使用“D”后缀（小写也可以，但建议使用大写）的小数都是double类型；float类型常量必须添加“F”后缀
字符类型（char）
布尔类型(boolean)
引用数据类型

引用数据类型是强大的数据类型，它是基于基本数据类型创建的。JavaSE中提供了一个超级类库，类库中包含了近万种引用数据类型。比如：数组、类、接口。

常量
常量就是不变的数据量, 在程序执行的过程中其值不可以发生改变

常量分类
整数类型

十进制表示方式：正常数字，如 13、25等
二进制表示方式：以0b(0B)开头，如0b1011 、0B1001
十六进制表示方式：以0x(0X)开头，数字以0-9及A-F组成  如0x23A2、0xa、0x10
八进制表示方式：以0开头，如01、07、0721
小数类型，如1.0、-3.15、3.168等

布尔类型， true、false

字符类型，字符必须使用’’ 包裹，并且其中只能且仅能包含一个字符。如'a'，'A', '0', '家'

字符串类型，一种引用类型，字符串必须使用""包裹，其中可以包含0~N个字符。如"我爱Java"，"0123"，""，"null"

在程序中输出Java中的常量

public class Main {
    public static void main(String[] args) {
        //输出整数 十进制
        System.out.println(50);//50
        //输出整数，二进制, 数字开头0B
        System.out.println(0B11);//3
        //输出整数，八进制，数字开头0
        System.out.println(051);//41
        //输出整数，十六进制，数组开头0X  0-9 A-F
        System.out.println(0XE);//14
        //输出浮点数据
        System.out.println(5.0);//5.0
        //输出布尔数据，只有2个值，true，false 关键字
        System.out.println(true);//true
        System.out.println(false);//false
        //输出字符常量，单引号包裹，只能写1个字符
        System.out.println('a');//a
        //输出字符串常量，双引号包裹，可以写0-n个字符
        System.out.println("HelloWorld");//HelloWorld
    }
}

变量
什么是变量?
变量是一个内存中的小盒子（小容器），容器是什么？生活中也有很多容器，例如水杯是容器，用来装载水；你家里的大衣柜是容器，用来装载衣裤；饭盒是容器，用来装载饭菜。

那么变量是装载什么的呢？答案是数据！结论：变量是内存中装载数据的小盒子，你只能用它来存数据和取数据。

定义变量
数据类型  变量名  =  数据值；
int         a    =  100;
变量使用的注意事项
变量定义后可以不赋值，使用时再赋值。不赋值不能使用。

int x;
x = 20; //为x赋值20
变量使用时有作用域的限制。


public static void main(String[] args) {
    int x = 20;
    {
        int y = 20;
    }
    System.out.println(x);//读取x变量中的值，再打印
    System.out.println(y);//读取y变量中的值失败，失败原因，找不到y变量，因为超出了y变量作用范围，所以不能使用y变量
}

变量不可以重复定义。

public static void main(String[] args){
      int x = 10;
      double x = 5.5;//编译失败，变量重复定义
}
数据类型转换
不同类型的变量可以在一起运算，但要先进行类型转换再运算。

范围小的数据类型值（如byte），可以直接转换为范围大的数据类型值（如int）；
范围大的数据类型值（如int），不可以直接转换为范围小的数据类型值（如byte）
数据范围从小到大依次列出：byte -> short -> int -> long -> float -> double

两种方式的数据类型转换

自动类型转换：表示范围小的数据类型转换成范围大的数据类型。格式：

范围大的数据类型 变量 = 范围小的数据类型值；
比如：double d = 1000; 
强制类型转换：表示范围大的数据类型转换成范围小的数据类型

范围小的数据类型  变量 = (范围小的数据类型) 范围大的数据类型值;
比如：int  i = (int)6.718;   //i的值为6
运算符
算数运算符
加号（ +）、减号和负号（ -）、乘号（ *）、除号（ /）、取模（%）、自增（++）、自减（--）以及等号（ =）的用法与其他所有编程语言都是类似的 。

++,--运算符后置时，先使用变量a原有值参与运算操作，运算操作完成后，变量a的值自增1或者自减1。

l ++，--运算符前置时，先将变量a的值自增1或者自减1，然后使用更新后的新值参与运算操作。

赋值运算符
赋值（=）、加后赋值（+=）、减后赋值（-=）、乘后赋值（*=）、整除后赋值（/=）取模后赋值（%=）的用法与其他所有编程语言都是类似的 。

关系运算符
等于（==）  不等于（!=） 小于（<） 大于（>）  小于等于（<=） 大于等于（>=）的用法与其他所有编程语言都是类似的 。

逻辑运算符
与（&&）、或（||）、非（!）的用法与其他所有编程语言都是类似的 。

短路：当使用与或者或时，只要能判断出结果则后边的部分就不再判断。

三元运算符
(条件表达式)？表达式1：表达式2；

int n = (3>2 && 4>6) ? 100 : 200;
//逻辑运算后的结果为false，运算结果为表达式2的值200,然后将结果200赋值给了变量n
商场库存清单案例
案例输出结果如下：



案例需求分析
观察清单后，可将清单分解为三个部分（清单顶部、清单中部、清单底部）

清单顶部为固定的数据，直接打印即可
清单中部为商品，为变化的数据，需要记录商品信息后，打印，经过观察，我们确定一项商品应该有如下几个属性：

品牌型号: 即商品名称，String型
尺寸：物品大小，double型
价格：物品单价，double型
配置：这一项为每种商品的配置信息，String型
库存数：这一项为每种商品的库存个数，int型
清单底部包含了统计操作，需经过计算后，打印，我们发现两个单独的可变化量：

总库存数：所有商品总个数，int型
库存商品总金额：所有商品金额，double型

public class Main {
    public static void main(String[] args) {
        //苹果笔记本电脑
        String macBrand = "MacBookAir";
        double macSize = 13.3;
        double macPrice = 6988.88;
        int macCount = 5;

        //联想Thinkpad笔记本电脑
        String thinkpadBrand = "ThinkpadT450";
        double thinkpadSize = 14.0;
        double thinkpadPrice = 5999.99;
        int thinkpadCount = 10;

        //华硕ASUS笔记本电脑
        String ASUSBrand = "ASUS-FL5800";
        double ASUSSize = 15.6;
        double ASUSPrice = 4999.50;
        int ASUSCount = 18;
        //统计所有库存商品数量与金额
        //统计库存总个数、库存总金额
        int totalCount = macCount + thinkpadCount + ASUSCount;
        double totalMoney = (macCount * macPrice) + (thinkpadCount * thinkpadPrice) + (ASUSCount * ASUSPrice);
        //打印库存清单顶部信息
        System.out.println("------------------------------商城库存清单-----------------------------");
        System.out.println("品牌型号    尺寸    价格    库存数");
        //打印库存清单中部信息
        System.out.println(macBrand + "    " + macSize + "    " + macPrice + "    " + macCount);
        System.out.println(thinkpadBrand + "    " + thinkpadSize + "    " + thinkpadPrice + "    " + thinkpadCount);
        System.out.println(ASUSBrand + "    " + ASUSSize + "    " + ASUSPrice + "    "+ASUSCount);
        //打印库存清单底部信息
        System.out.println("-----------------------------------------------------------------------");
        System.out.println("总库存数：" + totalCount);
        System.out.println("库存商品总金额：" + totalMoney);
    }
}
Java基础学习笔记三 Java基础语法
Scanner类
Scanner类属于引用数据类型，先了解下引用数据类型。

引用数据类型的使用
与定义基本数据类型变量不同，引用数据类型的变量定义及赋值有一个相对固定的步骤或格式。

数据类型  变量名  =  new 数据类型();
每种引用数据类型都有其功能，我们可以调用该类型实例使用其功能。

变量名.方法名();
Scanner类
Scanner类可以完成用户键盘录入，获取到录入的数据。

Scanner使用步骤：

导包： import java.util.Scanner; 

创建对象实例：Scanner sc = new Scanner(System.in); 

调用方法：

int  i = sc.nextInt(); 用来接收控制台录入的数字

String s = sc.next(); 用来接收控制台录入的字符串
了解完Scanner类，我们编写代码来使用下它：ScannerDemo01.java


import java.util.Scanner;
public class ScannerDemo01 {
    public static void main(String[] args) {
        //创建Scanner引用类型的变量
        Scanner sc = new Scanner(System.in);
        //获取数字
        System.out.println("请输入一个数字");
        int n = sc.nextInt();
        System.out.println("n的值为" + n);
        //获取字符串
        String str = sc.next();
        System.out.println("str的值为" + str);

    }
}

运行结果如下图所示:

 

 随机数类Random
用来产生随机数的类Random，它也属于引用数据类型。

这个Random类，它可以产生多种数据类型的随机数，在这里主要介绍生成整数与小数的方式。

方法简介

public int nextInt(int maxValue) 产生[0,maxValue)范围的随机整数，包含0，不包含maxValue；

public double nextDouble()  产生[0,1)范围的随机小数，包含0.0，不包含1.0。
 Random使用方式:

import导包： java.util.Random  

创建实例格式 ：Random 变量名 = new Random(); 

接下来，通过一段代码，学习下Random类的使用，RandomDemo.java


import java.util.Random;
public class RandomDemo {
    public static void main(String[] args) {
        // 创建Random类的实例
        Random r = new Random();
        // 得到0-100范围内的随机整数，将产生的随机整数赋值给i变量
        int i = r.nextInt(100);
        //得到0.0-1.0范围内的随机小数，将产生的随机小数赋值给d变量
        double d = r.nextDouble();
        System.out.println(i);
        System.out.println(d);
    }
}

运行结果如下图所示：

 

流程控制语句
选择结构if
 if语句

if语句是指如果满足某种条件，就进行某种处理。

在Java中，if语句的具体语法格式如下：


if (条件语句){

执行语句;

……

}

上述格式中，判断条件是一个布尔值，当判断条件为true时，{}中的执行语句才会执行。

接下来通过一段代码，学习一下if语句的具体用法，IfDemo01.java 


//定义了一个变量x，其初始值为5。在if语句的判断条件中判断x的值是否小于10，很明显条件成立，{}中的语句会被执行，变量x的值将进行自增。从运行结果可以看出，x的值已由原来的5变成了6。
public class IfDemo01 {
    public static void main(String[] args) {
        int x = 5;
        if (x < 10) {
            x++;
        }
        System.out.println("x=" + x);//x=6
    }
}

if…else语句
if…else语句是指如果满足某种条件，就进行某种处理，否则就进行另一种处理。if…else语句具体语法格式如下：


if (判断条件){
    执行语句1
    ……
}else{
    执行语句2
    ……
}

上述格式中，判断条件是一个布尔值。当判断条件为true时，if后面{}中的执行语句1会执行。当判断条件为false时，else后面{}中的执行语句2会执行。

接下来通过一段代码，来实现判断奇偶数的程序，IfDemo02.java


public class IfDemo02 {
    public static void main(String[] args) {
        int num = 19;
        if (num % 2 == 0) {
        // 判断条件成立，num被2整除
            System.out.println("num是一个偶数");
        } else {
            System.out.println("num是一个奇数");
        }
    }
}
//num是一个奇数

上述代码中，变量num的值为19，模以2的结果为1，不等于0，判断条件不成立。因此会执行else后面{}中的语句，打印“num是一个奇数”。

if…else if…else语句
if…else if…else语句用于对多个条件进行判断，进行多种不同的处理。if…else if…else语句具体语法格式如下：


if (判断条件1) {
　　执行语句1
} else if (判断条件2) {
　　执行语句2
}
...
else if (判断条件n) {
　　执行语句n
} else {
　　执行语句n+1
}

上述格式中，判断条件是一个布尔值。当判断条件1为true时，if后面{}中的执行语句1会执行。当判断条件1为false时，会继续执行判断条件2，如果为true则执行语句2，以此类推，如果所有的判断条件都为false，则意味着所有条件均未满足，else后面{}中的执行语句n+1会执行。

接下来通过一段代码，来实现对学生考试成绩进行等级划分的程序，IfDemo03.java


public class IfDemo03 {
    public static void main(String[] args) {
        int grade = 75; // 定义学生成绩
        if (grade > 80) {
        // 满足条件 grade > 80
            System.out.println("该成绩的等级为优");
        } else if (grade > 70) {
        // 不满足条件 grade > 80 ，但满足条件 grade > 70
            System.out.println("该成绩的等级为良");
        } else if (grade > 60) {
        // 不满足条件 grade > 70 ，但满足条件 grade > 60
            System.out.println("该成绩的等级为中");
        } else {
        // 不满足条件 grade > 60
            System.out.println("该成绩的等级为差");
        }
    }
}
//该成绩的等级为良

上述代码中，定义了学生成绩grade为75。它不满足第一个判断条件grade>80，会执行第二个判断条件grade>70，条件成立，因此会打印“该成绩的等级为良”。

选择结构if语句与三元运算转换
三元运算符，它和if-else语句类似，语法如下：

判断条件 ? 表达式1 : 表达式2
三元运算符会得到一个结果，通常用于对某个变量进行赋值，当判断条件成立时，运算结果为表达式1的值，否则结果为表达式2的值。

例如求两个数x、y中的较大者，如果用if…else语句来实现，具体代码如下：


int x = 0;
int y = 1;
int max;
if (x > y) {
　　max = x;
} else {
　　max = y;
}

可以替换为

int x=0;
int y=1;
int max = x > y ? x : y;
switch语句
根据一个整数表达式的值， switch 语句可从一系列代码选出一段执行。它的格式如下：


switch(整数选择因子或者字符串或者枚举) {
　　case 整数值 1 : 语句; break;
　　case 整数值 2 : 语句; break;
　　case 整数值 3 : 语句; break;
　　case 整数值 4 : 语句; break;
　　case 整数值 5 : 语句; break;
　　//..
　　default:语句;92
}

switch 能将整数选择因子的结果与每个整数值比较。若发现相符的，就执行对应的语句（简单或复合语句）。若没有发现相符的，就执行default 语句。 示例：VowelsAndConsonants.java


public class VowelsAndConsonants {
    public static void main(String[] args) {
        char c = (char) (Math.random() * 26 + 'a');
        System.out.print(c + ": ");
        switch (c) {
            case 'a':
            case 'e':
            case 'i':
            case 'o':
            case 'u':
                System.out.println("vowel");
                break;
            case 'y':
            case 'w':
                System.out.println(
                        "Sometimes a vowel");
                break;
            default:
                System.out.println("consonant");
        }
    }
}

switch语句接受的数据类型
switch语句中的表达式的数据类型,是有要求的

JDK1.0 - 1.4 数据类型接受 byte short int char
JDK1.5 数据类型接受 byte short int char enum(枚举)
JDK1.7 数据类型接受 byte short int char enum(枚举), String
case穿透
在使用switch语句的过程中，如果多个case条件后面的执行语句是一样的，则该执行语句只需书写一次即可，这是一种简写的方式。
例如，要判断一周中的某一天是否为工作日，同样使用数字1~7来表示星期一到星期天，当输入的数字为1、2、3、4、5时就视为工作日，否则就视为休息日。如下所示。SwitchDemo02.java


public class SwitchDemo02 {
    public static void main(String[] args) {
        int week = 2;
        switch (week) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                // 当 week 满足值 1、2、3、4、5 中任意一个时，处理方式相同
                System.out.println("今天是工作日");
                break;
            case 6:
            case 7:
                // 当 week 满足值 6、7 中任意一个时，处理方式相同
                System.out.println("今天是休息日");
                break;
        }
    }
}



上述代码中，当变量week值为1、2、3、4、5中任意一个值时，处理方式相同，都会打印“今天是工作日”。同理，当变量week值为6、7中任意一个值时，打印“今天是休息日”。

循环语句
while语句
while循环语句和选择结构if语句有些相似，都是根据条件判断来决定是否执行大括号内的执行语句。区别在于，while语句会反复地进行条件判断，只要条件成立，{}内的执行语句就会执行，直到条件不成立，while循环结束。while循环语句的语法结构如下：

while(循环条件){
    执行语句
    ………
}
在上面的语法结构中，{}中的执行语句被称作循环体，循环体是否执行取决于循环条件。当循环条件为true时，循环体就会执行。循环体执行完毕时会继续判断循环条件，如条件仍为true则会继续执行，直到循环条件为false时，整个循环过程才会结束。

接下来通过一段代码，来实现打印1~4之间的自然数，WhileDemo.java


public class WhileDemo {
    public static void main(String[] args) {
        int x = 1; // 定义变量x，初始值为1
        while (x <= 4) { // 循环条件
            System.out.println("x = " + x); // 条件成立，打印x的值
            x++; // x进行自增
        }
    }
}

//x = 1
//x = 2
//x = 3
//x = 4

在上述代码中，x初始值为1，在满足循环条件x <= 4的情况下，循环体会重复执行，打印x的值并让x进行自增。因此打印结果中x的值分别为1、2、3、4。

值得注意的是，代码x++用于在每次循环时改变变量x的值，从而达到最终改变循环条件的目的。如果没有这行代码，整个循环会进入无限循环的状态，永远不会结束。

循环语句for
for循环语句是最常用的循环语句，一般用在循环次数已知的情况下。for循环语句的语法格式如下：

for（初始化表达式; 循环条件; 操作表达式）{

    执行语句
    ………
}
在上面的语法结构中，for关键字后面()中包括了三部分内容：初始化表达式、循环条件和操作表达式，它们之间用“;”分隔，{}中的执行语句为循环体。

接下来分别用①表示初始化表达式、②表示循环条件、③表示操作表达式、④表示循环体，通过序号来具体分析for循环的执行流程。具体如下：

for（① ; ② ; ③）{
　　④
}
第一步，执行①
第二步，执行②，如果判断结果为true，执行第三步，如果判断结果为false，执行第五步
第三步，执行④
第四步，执行③，然后重复执行第二步
第五步，退出循环
接下来通过一个案例对自然数1~4进行求和，如下所示。ForDemo01.java


public class ForDemo01 {
    public static void main(String[] args) {
        int sum = 0; // 定义变量sum，用于记住累加的和
        for (int i = 1; i <= 4; i++) { // i的值会在1~4之间变化
            sum += i; // 实现sum与i的累加
        }
        System.out.println("sum = " + sum); // 打印累加的和
    }
}

上述代码中，变量i的初始值为1，在判断条件i<=4为true的情况下，会执行循环体sum+=i，执行完毕后，会执行操作表达式i++，i的值变为2，然后继续进行条件判断，开始下一次循环，直到i=5时，条件i<=4为false，结束循环，执行for循环后面的代码，打印“sum=10”。

do…while语句
do…while循环语句和while循环语句功能类似，其语法结构如下：

do {

    执行语句
    ………
} while(循环条件);
在上面的语法结构中，关键字do后面{}中的执行语句是循环体。do…while循环语句将循环条件放在了循环体的后面。这也就意味着，循环体会无条件执行一次，然后再根据循环条件来决定是否继续执行。

接下来使用do…while循环语句来实现打印1~4之间的自然数DoWhileDemo.java。


public class DoWhileDemo {
    public static void main(String[] args) {
        int x = 1; // 定义变量x，初始值为1
        do {
            System.out.println("x = " + x); // 打印x的值
            x++; // 将x的值自增
        } while (x <= 4); // 循环条件
    }
}

do …while循环和while循环能实现同样的功能。然而在程序运行过程中，这两种语句还是有差别的。如果循环条件在循环语句开始时就不成立，那么while循环的循环体一次都不会执行，而do…while循环的循环体还是会执行一次。若将DoWhileDemo.java中的循环条件x<=4改为x < 1，DoWhileDemo.java运行结果会打印x=1，而WhileDemo.java运行结果什么也不会打印。

无限循环
最简单无限循环格式：

while(true){}

或

for(;;){}
无限循环存在的原因是并不知道循环多少次，而是根据某些条件，来控制循环。

循环嵌套
嵌套循环是指在一个循环语句的循环体中再定义一个循环语句的语法结构。while、do…while、for循环语句都可以进行嵌套，并且它们之间也可以互相嵌套，如最常见的在for循环中嵌套for循环，格式如下：


for(初始化表达式; 循环条件; 操作表达式) {
    ………
    for(初始化表达式; 循环条件; 操作表达式) {
        执行语句
        ………
     }
    ………
}

接下来实现使用“*”打印直角三角形，如下所示。ForForDemo.java


public class ForForDemo {
    public static void main(String[] args) {
        int i, j; // 定义两个循环变量
        for (i = 1; i <= 9; i++) { // 外层循环
            for (j = 1; j <= i; j++) { // 内层循环
                System.out.print("*"); // 打印*
            }
            System.out.print("\n"); // 换行
        }
    }
}

运行结果如下所示：



在上述代码中定义了两层for循环，分别为外层循环和内层循环，外层循环用于控制打印的行数，内层循环用于打印“*”，每一行的“*”个数逐行增加，最后输出一个直角三角形。由于嵌套循环程序比较复杂，下面分步骤进行详细地讲解，具体如下：

第一步，在第3行代码定义了两个循环变量i和j，其中i为外层循环变量，j为内层循环变量。
第二步，在第4行代码将i初始化为1，条件i <= 9为true，首次进入外层循环的循环体。
第三步，在第5行代码将j初始化为1，由于此时i的值为1，条件j <= i为true，首次进入内层循环的循环体，打印一个“*”。
第四步，执行第5行代码中内层循环的操作表达式j++，将j的值自增为2。
第五步，执行第5行代码中的判断条件j<=i，判断结果为false，内层循环结束。执行后面的代码，打印换行符。
第六步，执行第4行代码中外层循环的操作表达式i++，将i的值自增为2。
第七步，执行第4行代码中的判断条件i<=9，判断结果为true，进入外层循环的循环体，继续执行内层循环。
第八步，由于i的值为2，内层循环会执行两次，即在第2行打印两个“*”。在内层循环结束时会打印换行符。
第九步，以此类推，在第3行会打印3个“*”，逐行递增，直到i的值为10时，外层循环的判断条件i <= 9结果为false，外层循环结束，整个程序也就结束了。
跳转语句（break、continue）
跳转语句用于实现循环执行过程中程序流程的跳转，在Java中的跳转语句有break语句和continue语句。接下来分别进行详细地讲解。

break语句
在switch条件语句和循环语句中都可以使用break语句。当它出现在switch条件语句中时，作用是终止某个case并跳出switch结构。当它出现在循环语句中，作用是跳出循环语句，执行后面的代码。

接下来通过下面一段代码，实现将当变量x的值为3时，使用break语句跳出循环，代码如下所示。BreakDemo.java


public class BreakDemo {
    public static void main(String[] args) {
        int x = 1; // 定义变量x，初始值为1
        while (x <= 4) { // 循环条件
            System.out.println("x = " + x); // 条件成立，打印x的值
            if (x == 3) {
                break;
            }
            x++; // x进行自增
        }
    }
}


在上述带代码中，通过while循环打印x的值，当x的值为3时使用break语句跳出循环。因此打印结果中并没有出现“x=4”。
标记
当break语句出现在嵌套循环中的内层循环时，它只能跳出内层循环，如果想使用break语句跳出外层循环则需要对外层循环添加标记。接下来将ForForDemo.java稍作修改，控制程序只打印4行“*”，如下所示。BreakDemo02.java


public class BreakDemo02 {
    public static void main(String[] args) {
        int i, j; // 定义两个循环变量
        AA: for (i = 1; i <= 9; i++) { // 外层循环
            for (j = 1; j <= i; j++) { // 内层循环
                if (i > 4) { // 判断i的值是否大于4
                    break AA; // 跳出外层循环
                }
                System.out.print("*"); // 打印*
            }
            System.out.print("\n"); // 换行
        }
    }
}



BreakDemo02.java与ForForDemo.java实现原理类似，只是在外层for循环前面增加了标记“AA”。当i>4时，使用break AA;语句跳出外层循环。因此程序只打印了4行“*”。

continue语句
continue语句用在循环语句中，它的作用是终止本次循环，执行下一次循环。接下来通过一个练习对1~100之内的奇数求和，ContinueDemo.java


public class ContinueDemo {
    public static void main(String[] args) {
        int sum = 0; // 定义变量sum，用于记住和
        for (int i = 1; i <= 100; i++) {
            if (i % 2 == 0) { // i是一个偶数，不累加
                continue; // 结束本次循环
            }
            sum += i; // 实现sum和i的累加
        }
        System.out.println("sum = " + sum);
    }
}
//sum = 2500

上述代码中，使用for循环让变量i的值在1~100之间循环，在循环过程中，当i的值为偶数时，将执行continue语句结束本次循环，进入下一次循环。当i的值为奇数时，sum和i进行累加，最终得到1~100之间所有奇数的和，打印“sum = 2500”。

在嵌套循环语句中，continue语句后面也可以通过使用标记的方式结束本次外层循环，用法与break语句相似，在此不再举例说明。

猜数字案例
案例介绍
猜数字案例是要完成什么样的功能呢？顾名思义，这个游戏就是你出个数字、我来猜。

游戏操作如下：

后台预先生成一个1-100之间的随机数，用户键盘录入猜数字

如果猜对了，打印“恭喜您，答对了”

如果猜错了

猜大了：打印“sorry，您猜大了!”
猜小了：打印“sorry，您猜小了!”
直到数字猜到为止
思路
1.通过Random类中方法nextInt（），生成一个1-100之间的随机数

2.输入猜的数字

3.通过while循环，进行猜数字对错判断

猜对，跳出循环，游戏结束

猜错了，根据结果，给出提示，接着猜数字，游戏继续

如果猜大了，打印sorry，您猜大了!继续下一次循环

如果猜小了，打印sorry，您猜小了!继续下一次循环

实现代码步骤
分析完毕之后，完成代码的编写：GuessNumber.java


import java.util.Random;
import java.util.Scanner;

public class GuessNumber {
    public static void main(String[] args) {
//1.通过Random类中方法nextInt（），生成一个1-100之间的随机数
        int randomNumber = new Random().nextInt(100);
        System.out.println("随机数已生成！");
//2.输入猜的数字
        System.out.println("----请输入您猜的数字：----");
        Scanner sc = new Scanner(System.in);
        int enterNumber = sc.nextInt();
//3.通过while循环，进行猜数字对错判断
//猜对，跳出循环，游戏结束
        while (enterNumber != randomNumber) {
//猜错了，根据结果，给出提示，接着猜数字，游戏继续
            if (enterNumber > randomNumber) {
//如果猜大了，打印sorry，您猜大了!继续下一次循环
                System.out.println("sorry，您猜大了!继续下一次循环");
            } else {
//如果猜小了，打印sorry，您猜小了!继续下一次循环
                System.out.println("sorry，您猜小了!继续下一次循环");
            }
//输入猜的数字
            System.out.println("----请输入您猜的数字：----");
            enterNumber = sc.nextInt();
        }
        System.out.println("恭喜您，答对了！");
    }

}
Java基础学习笔记四 Java基础语法
数组
数组的需求
现在需要统计某公司员工的工资情况，例如计算平均工资、最高工资等。假设该公司有50名员工，用前面所学的知识完成，那么程序首先需要声明50个变量来分别记住每位员工的工资，这样做会显得很麻烦.

数组的概述
数组是指一组数据的集合，数组中的每个数据被称作元素。在数组中可以存放任意类型的元素，但同一个数组里存放的元素类型必须一致。

数组的定义
格式:

数据类型[] 数组名 = new 数据类型[元素个数或数组长度];

举例:int[] x = new int[100];
要点说明

数据类型: 数组中存储元素的数据类型
 [] 表示数组的意思
变量名 自定义标识符
new 创建容器关键字
元素个数,就是数组中,可以存储多少个数据 (恒定, 定长)
数组是一个容器: 存储到数组中的每个元素,都有自己的自动编号(索引(index), 下标, 角标)
访问数组存储的元素,必须依赖于索引,  数组名[索引]
数组中最小的索引是0，最大的索引是“数组的长度-1”。
在程序中可以通过“数组名.length”的方式来获得数组的长度，即元素的个数。

接下来，通过一个案例来演示如何定义数组以及访问数组中的元素，如下所示。ArrayDemo01.java


 public class ArrayDemo01 {
    public static void main(String[] args) {
               int[] arr; // 声明变量
               arr = new int[3]; // 创建数组对象
               System.out.println("arr[0]=" + arr[0]); // 访问数组中的第一个元素
               System.out.println("arr[1]=" + arr[1]); // 访问数组中的第二个元素
               System.out.println("arr[2]=" + arr[2]); // 访问数组中的第三个元素
               System.out.println("数组的长度是：" + arr.length); // 打印数组长度
           }
}



如果在使用数组时，不想使用这些默认初始值，也可以显式地为这些元素赋值。接下来通过一个程序来学习如何为数组的元素赋值，如下所示。ArrayDemo02.java


 public class ArrayDemo02 {
     public static void main(String[] args) {
                int[] arr = new int[4]; // 定义可以存储4个整数的数组
                arr[0] = 1; // 为第1个元素赋值1
                arr[1] = 2; // 为第2个元素赋值2
                // 下面的代码是打印数组中每个元素的值
                System.out.println("arr[0]=" + arr[0]);
                System.out.println("arr[1]=" + arr[1]);
                System.out.println("arr[2]=" + arr[2]);
                System.out.println("arr[3]=" + arr[3]);
            }
}



在定义数组时只指定数组的长度，由系统自动为元素赋初值的方式称作动态初始化。

在初始化数组时还有一种方式叫做静态初始化，就是在定义数组的同时就为数组的每个元素赋值。数组的静态初始化有两种方式，具体格式如下：

方式1  　　类型[] 数组名 = new 类型[]{元素，元素，……};
方式2 　　 类型[] 数组名 = {元素，元素，元素，……};
上面的两种方式都可以实现数组的静态初始化，但是为了简便，建议采用第二种方式。接下来通过一段代码来演示数组静态初始化的效果，如下所示。ArrayDemo03.java


 public class ArrayDemo03 {
    public static void main(String[] args) {
                int[] arr = { 1, 2, 3, 4 }; // 静态初始化
                // 下面的代码是依次访问数组中的元素
                System.out.println("arr[0] = " + arr[0]);
                System.out.println("arr[1] = " + arr[1]);
                System.out.println("arr[2] = " + arr[2]);
                System.out.println("arr[3] = " + arr[3]);
            }
 }



在操作数组时，经常需要依次访问数组中的每个元素，这种操作称作数组的遍历。接下来通过一个案例来学习如何使用for循环来遍历数组，如下所示。ArrayDemo04.java


public class ArrayDemo04 {
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3, 4, 5 }; // 定义数组
        // 使用for循环遍历数组的元素
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]); // 通过索引访问元素
        }
    }
}



数组在编写程序时应用非常广泛，灵活地使用数组对实际开发很重要。接下来，本节将针对数组的常见操作进行详细地讲解，如数组的遍历、最值的获取、数组的排序等。

在操作数组时，经常需要获取数组中元素的最值。接下来通过一个案例来演示如何获取数组中元素的最大值，如下所示。ArrayDemo05.java


public class ArrayDemo05 {
    public static void main(String[] args) {
        int[] arr = { 4, 1, 6, 3, 9, 8 }; // 定义一个数组
        int max = arr[0]; // 定义变量max用于记住最大数，首先假设第一个元素为最大值
        // 下面通过一个for循环遍历数组中的元素
        for (int x = 1; x < arr.length; x++) {
            if (arr[x] > max) { // 比较 arr[x]的值是否大于max
                max = arr[x]; // 条件成立，将arr[x]的值赋给max
            }
        }
        System.out.println("max=" + max); // 打印最大值
    }
}
//max=9

每个数组的索引都有一个范围，即0~length-1。在访问数组的元素时，索引不能超出这个范围，否则程序会报错

在使用变量引用一个数组时，变量必须指向一个有效的数组对象，如果该变量的值为null，则意味着没有指向任何数组，此时通过该变量访问数组的元素会出现空指针异常，接下来通过一个案例来演示这种异常，如下所示。ArrayDemo07.java


 public class ArrayDemo07 {
     public static void main(String[] args) {
                int[] arr = new int[3]; // 定义一个长度为3的数组
                arr[0] = 5; // 为数组的第一个元素赋值
                System.out.println("arr[0]=" + arr[0]); // 访问数组的元素
                arr = null; // 将变量arr置为null
                System.out.println("arr[0]=" + arr[0]); // 访问数组的元素
            }
}



二维数组
二维数组的定义有很多方式，接下来针对几种常见的方式进行详细地讲解，具体如下：

第一种方式： int[][] arr = new int[3][4]; 

第二种方式： int[][] arr = new int[3][]; 

第三种方式： int[][] arr = {{1,2},{3,4,5,6},{7,8,9}}; 

对二维数组中元素的访问也是通过角标的方式，如需访问二维数组中第一个元素数组的第二个元素，具体代码如下：

arr[0][1];
操作二维数组时，经常需要获取数组中元素的值。接下来通过一个案例来演示如何获取数组中元素值，如下所示。ArrayDemo08.java


class ArrayDemo08 {
    public static void main(String[] args){
        //定义二维数组的方式
        int[][] arr = new int[3][4];

        System.out.println( arr );
        System.out.println("二维数组的长度: " + arr.length);
        //获取二维数组的3个元素
        System.out.println( arr[0] );
        System.out.println( arr[1] );
        System.out.println( arr[2] );

        System.out.println("打印第一个一维数组的元素值");
        System.out.println( arr[0][0] );
        System.out.println( arr[0][1] );//访问的为二维数组中第1个一维数组的第2个元素
        System.out.println( arr[0][2] );
        System.out.println( arr[0][3] );

        System.out.println("打印第二个一维数组的元素值");
        System.out.println( arr[1][0] );
        System.out.println( arr[1][1] );
        System.out.println( arr[1][2] );
        System.out.println( arr[1][3] );

        System.out.println("打印第三个一维数组的元素值");
        System.out.println( arr[2][0] );
        System.out.println( arr[2][1] );
        System.out.println( arr[2][2] );
        System.out.println( arr[2][3] );
    }
}

运行结果：


[[I@1540e19d
二维数组的长度: 3
[I@677327b6
[I@14ae5a5
[I@7f31245a
打印第一个一维数组的元素值
0
0
0
0
打印第二个一维数组的元素值
0
0
0
0
打印第三个一维数组的元素值
0
0
0
0

学习完了数组元素的访问，我们来学习下数组的遍历及数组的元素累加和操作。


public class ArrayDemo09 {
    public static void main(String[] args){
        //一维数组的求累加和并遍历
        int[] arr = {10,20,30,40,50};
        int sum = 0;
        for (int i=0; i<arr.length; i++) {
            //System.out.println(arr[i]);
            sum += arr[i];
        }
        System.out.println("sum= " + sum);
        System.out.println("---------------------");

//二维数组的求累加和并遍历
        int[][] arr2 = { {1,2},{3,4,5},{6,7,8,9,10} };
        int sum2 = 0;
        for (int i=0; i<arr2.length; i++) {
            for (int j=0; j<arr2[i].length; j++) {
                //System.out.println(arr2[i][j])
                sum2 += arr2[i][j];
            }
        }
        System.out.println("sum2= "+ sum2);
    }
}



接下来通过一个案例来熟悉二维数组的使用。例如要统计一个公司三个销售小组中每个小组的总销售额以及整个公司的销售额。如下所示

第一小组销售额为{11, 12}万元
第二小组销售额为{21, 22, 23}万元
第三小组销售额为{31, 32, 33, 34}万元。

/**
 * Created by yang on 2017/7/2.
 */
public class ArrayDemo10 {
    public static void main(String[] args) {
        int[][] arr = new int[3][]; // 定义一个长度为3的二维数组
        arr[0] = new int[]{11, 12}; // 为数组的元素赋值
        arr[1] = new int[]{21, 22, 23};
        arr[2] = new int[]{31, 32, 33, 34};

        int sum = 0; // 定义变量记录总销售额
        for (int i = 0; i < arr.length; i++) { // 遍历数组元素
            int groupSum = 0; // 定义变量记录小组销售总额
            for (int j = 0; j < arr[i].length; j++) { // 遍历小组内每个人的销售额
                groupSum = groupSum + arr[i][j];
            }
            sum = sum + groupSum; // 累加小组销售额
            System.out.println("第" + (i + 1) + "小组销售额为：" + groupSum + " 万元");
        }
        System.out.println("总销售额为: " + sum + " 万元");
    }
}



JVM内存划分 
 JVM对自己的内存划分为5个区域

寄存器:内存和CUP之间
本地方法栈: JVM调用了系统中的功能
方法和数据共享: 运行时期class文件进入的地方
方法栈:所有的方法运行的时候进入内存
堆:存储的是容器和对象
数组的内存
int[] x; // 声明一个int[]类型的变量
x = new int[100]; // 创建一个长度为100的数组
接下来，通过两张内存图来详细地说明数组在创建过程中内存的分配情况。
第一行代码 int[] x; 声明了一个变量x，该变量的类型为int[]，即一个int类型的数组。变量x会占用一块内存单元，它没有被分配初始值
第二行代码 x = new int[100]; 创建了一个数组，将数组的地址赋值给变量x。在程序运行期间可以使用变量x来引用数组，这时内存中的状态会发生变化



数组中常见的异常
数组操作中,常见的两个异常
数组的索引越界异常
空指针异常

二维数组内存图
举例:int[][] arr = new int[3][4];
外层数组长在内存开辟连续的3个大的内存空间,每一个内存空间都对应的有地址值
每一个大内存空间里又开辟连续的四个小的内存空间.

 

方法
在java中，方法就是用来完成解决某件事情或实现某个功能的办法。

方法的语法格式
在Java中，声明一个方法的具体语法格式如下：

修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2,．．．．．．){ 
    执行语句
    ……… 
    return 返回值;
}
对于上面的语法格式中具体说明如下：

修饰符：方法的修饰符比较多，有对访问权限进行限定的，有静态修饰符static，还有最终修饰符final等，这些修饰符在后面的学习过程中会逐步介绍
返回值类型：用于限定方法返回值的数据类型
参数类型：用于限定调用方法时传入参数的数据类型
参数名：是一个变量，用于接收调用方法时传入的数据
return关键字：用于结束方法以及返回方法指定类型的值
返回值：被return语句返回的值，该值会返回给调用者
方法使用的注意事项
方法不调用，自己不执行
方法中不能定义方法， 但是，方法中可以调用方法
方法定义的位置在类中，其他方法的外面
方法中的“参数类型 参数名1，参数类型 参数名2”被称作参数列表，它用于描述方法在被调用时需要接收的参数，如果方法不需要接收任何参数，则参数列表为空，即()内不写任何内容。
如果方法没有明确的返回值类型，使用'空'类型， void表示
void只能在方法返回值类型位置使用，不能作为普通的数据类型使用
如果方法返回值类型为void类型，可以省略 return ;
接下来通过一个案例来演示方法的定义与使用，如下图所示。MethodDemo01.java


public class MethodDemo01 {
    public static void main(String[] args) {
        int area = getArea(3, 5); // 调用 getArea方法
        System.out.println(" The area is " + area);
    }

    // 下面定义了一个求矩形面积的方法，接收两个参数，其中x为高，y为宽
    public static int getArea(int x, int y) {
        int temp = x * y; // 使用变量temp记住运算结果
        return temp; // 将变量temp的值返回
    }
}

 方法的重载
Java允许在一个类中定义多个名称相同的方法，但是参数的类型或个数必须不同，这就是方法的重载。

比如，下面的三个方法互为重载关系

public static int add(int x,int y) {逻辑} //两个整数加法

public static int add(int x,int y,int z) {逻辑} //三个整数加法

public static int add(double x,double y) {逻辑} //两个小数加法
接下来演示方法重载的方式如下所示。MethodDemo03.java


public class MethodDemo03 {
    public static void main(String[] args) {
        // 下面是针对求和方法的调用
        int sum1 = add(1, 2);
        int sum2 = add(1, 2, 3);
        double sum3 = add(1.2, 2.3);
        // 下面的代码是打印求和的结果
        System.out.println("sum1=" + sum1);
        System.out.println("sum2=" + sum2);
        System.out.println("sum3=" + sum3);
    }

    // 下面的方法实现了两个整数相加
    public static int add(int x, int y) {
        return x + y;
    }
    // 下面的方法实现了三个整数相加
    public static int add(int x, int y, int z) {
        return x + y + z;
    }
    // 下面的方法实现了两个小数相加
    public static double add(double x, double y) {
        return x + y;
    }
}



重载的注意事项
重载方法参数必须不同：

参数个数不同，如method(int x)与method(int x,int y)不同
参数类型不同，如method(int x)与method(double x)不同
参数顺序不同，如method(int x,double y)与method(double x,int y)不同
重载只与方法名与参数类型相关，与返回值无关。如void method(int x)与int method(int y)不是方法重载，不能同时存在

重载与具体的变量标识符无关。如method(int x)与method(int y)不是方法重载，不能同时存在

 参数传递
定义方法时，参数列表中的变量，我们称为形式参数

调用方法时，传入给方法的数值，我们称为实际参数

参数传递图解与结论
 

通过上面的两段程序可以得出如下结论：

当调用方法时，如果传入的数值为基本数据类型（包含String类型），形式参数的改变对实际参数不影响
当调用方法时，如果传入的数值为引用数据类型（String类型除外），形式参数的改变对实际参数有影响
 库存管理案例
现在，我们将原有的库存管理案例，进行业务逻辑的封装。

将对下列功能进行方法封装：

打印库存清单功能
库存商品数量修改功能
退出程序功能
编写代码，StockMamager.java


import java.util.Scanner;

/**
 * Created by yang on 2017/7/2.
 */
public class StockMamager {
    /**
     * 库存管理功能菜单
     * @return 管理员键盘输入的功能操作序号
     */
    public static int chooseFunction() {
        System.out.println("-------------库存管理------------");
        System.out.println("1.查看库存清单");
        System.out.println("2.修改商品库存数量");
        System.out.println("3.退出");
        System.out.println("请输入要执行的操作序号：");
        //接收键盘输入的功能选项序号
        Scanner sc = new Scanner(System.in);
        int choose = sc.nextInt();
        return choose;
    }
    /**
     * 查看库存清单
     * @param brands 商品品牌型号
     * @param sizes 商品尺寸大小
     * @param prices 商品价格
     * @param counts 商品库存个数
     */
    public static void printStore(String[] brands, double[] sizes, double[] prices, int[] counts) {
        //统计总库存个数、统计库存总金额
        int totalCount = 0;
        double totalMoney = 0.0;
        for (int i = 0; i < brands.length; i++) {
            totalCount += counts[i];
            totalMoney += counts[i] * prices[i];
        }
        //列表顶部
        System.out.println("---------------------------查看库存清单--------------------------");
        System.out.println("品牌型号        尺寸    价格    库存数");
        //列表中部
        for (int i = 0; i < brands.length; i++) {
            System.out.println(brands[i]+"    "+sizes[i]+"    "+prices[i]+"    "+counts[i]);
        }
        //列表底部
        System.out.println("-------------------------------------------------------------");
        System.out.println("总库存数："+totalCount);
        System.out.println("库存商品总金额："+totalMoney);
    }

    /**
     * 修改商品库存数量
     * @param brands 商品品牌型号
     * @param counts 商品库存个数
     */
    public static void update(String[] brands, int[] counts){
        System.out.println("------------修改商品库存数量-----------");
        for (int i = 0; i < brands.length; i++) {
            System.out.println("请输入"+ brands[i] +"商品库存数");
            counts[i] = new Scanner(System.in).nextInt();
        }
    }

    /**
     * 退出
     */
    public static void exit(){
        System.out.println("----------------退出---------------");
        System.out.println("您已退出系统");
    }

    public static void main(String[] args) {
        //记录库存商品信息
        //品牌型号
        String[] brands = new String[]{"MacBookAir", "ThinkpadT450"};
        //尺寸大小
        double[] sizes = new double[]{13.3, 14.0};
        //价格
        double[] prices = new double[]{6988.88, 5999.99};
        //库存个数
        int[] counts = new int[]{0, 0};

        //通过while循环模拟管理员进行功能重复选择操作
        while (true) {
            //打印功能菜单操作,接收键盘输入的功能选项序号
            int choose = chooseFunction();
            //执行序号对应的功能
            switch (choose) {
                case 1://查看库存清单
                    printStore(brands, sizes, prices, counts);
                    break;
                case 2://修改商品库存数量
                    update(brands, counts);
                    break;
                case 3://退出
                    exit();
                    return;
                default:
                    System.out.println("----------------------------------");
                    System.out.println("功能选择有误，请输入正确的功能序号!");
                    break;
            }
        }
    }
}
Java基础学习笔记六 Java基础语法之类和ArrayList
引用数据类型
引用数据类型分类，提到引用数据类型（类），其实我们对它并不陌生，如使用过的Scanner类、Random类。
我们可以把类的类型为两种：

第一种，Java为我们提供好的类，如Scanner类，Random类等，这些已存在的类中包含了很多的方法与属性，可供我们使用。
第二种，我们自己创建的类，按照类的定义标准，可以在类中包含多个方法与属性，来供我们使用。
这里我们主要介绍第二种情况的简单使用。

自定义数据类型概述
在Java中，将现实生活中的事物抽象成了代码。这时，我们可以使用自定义的数据类型（类）来描述（映射）现实生活中的事物。
类，它是引用数据类型，与之前学习的所有引用数据类型相同，自定义类也是一种数据类型。只是自定义类型并非Java为我们预先提供好的类型，而是我们自己定义的一种引用数据类型用来描述一个事物。

类的定义与使用
java代码映射成现实事物的过程就是定义类的过程。
我们就拿一部手机进行分析，它能用来做什么呢？它可以打电话，上网，聊微信等，这些就是手机所提供的功能，也就是方法；手机也有它的特征，如颜色、尺寸大小、品牌型号等，这些就是手机的特征，也就是属性。
目前，我们只关注类中的属性，类中的方法在面向对象部分再进行学习。

类的定义格式
创建java文件，与类名相同

public class 类名{
    数据类型 属性名称1；
    数据类型 属性名称2；
    …
}
通过类的定义格式，来进行手机类的描述，如下所示


public class Phone {
    /*
    * 属性
    */
    String brand;// 品牌型号
    String color;// 颜色
    double size; // 尺寸大小
}

上述代码，就是创建一个类的的过程，类的名称我们给起名为Phone，类中包含了三个属性（brand品牌型号、color颜色、size尺寸大小）。注意，类中定义的属性没有个数要求。

类的使用格式
Phone类定义好后，我们就可以使用这个类了，使用方式和使用引用数据类型Scanner类相似。格式如下：

导包：我们将所有的类放到同一个文件夹下，可以避免导包;
创建对象：数据类型 变量名 = new 数据类型();
调用方法：目前我们定义的自定义类不涉及方法，只是属性;
访问属性：变量名.属性 (这是当前的方式，后期会采取调用方法的方式替代掉直接访问的方式来完成对属性的访问。)
当有了Phone数据类型的变量后，我们就可以使用Phone类中的属性了。对属性的访问我们来演示一下，如下所示：


package arraylist;

public class Test {
    public static void main(String[] args) {
//定义了一个Phone类型的变量p
        Phone p = new Phone();
/*
* 通过p,使用Phone中的属性
*/
//访问p中的brand品牌属性
        p.brand = "苹果6s";//为p中brand属性赋值为 苹果6s
//访问p中的color颜色属性
        p.color = "白色";//为p中color属性赋值为”白色”
//访问p中的size尺寸大小属性
        p.size = 5.5;//为p中size属性赋值为5.5
        System.out.println("手机品牌为" + p.brand);
        System.out.println("手机颜色为" + p.color);
        System.out.println("手机尺寸大小为" + p.size);
    }
}
//手机品牌为苹果6s
//手机颜色为白色
//手机尺寸大小为5.5

自定义类型注意事项与内存图
上述代码中，通过类Phone创建出来的变量p，它相当于我们生活中的盒子，里面包含了它能够使用的属性。
通过 p.属性名 就可以对属性进行操作
与引用类型数组类似，引用类型的自定义类型的变量，直接变量时，结果为对象地址值，这里可以通过内存图简单解释。



下面再来看看某个类创建两个对象的内存图：



 

ArrayList集合
在前面我们学习了数组，数组可以保存多个元素，但在某些情况下无法确定到底要保存多少个元素，此时数组将不再适用，因为数组的长度不可变。为了保存这些数目不确定的元素，JDK中提供了一系列特殊的类，这些类可以存储任意类型的元素，并且长度可变，统称为集合。在这里，我们先介绍ArrayList集合，其他集合在后续课程中学习。
ArrayList集合是程序中最常见的一种集合，它属于引用数据类型（类）。在ArrayList内部封装了一个长度可变的数组，当存入的元素超过数组长度时，ArrayList会在内存中分配一个更大的数组来存储这些元素，因此可以将ArrayList集合看作一个长度可变的数组。

集合的创建
创建集合的常用格式在此说明一下：
1、导包：import java.util.ArrayList;
2、创建对象：与其他普通的引用数据类型创建方式完全相同，但是要指定容器中存储的数据类型：
3、ArrayList<要存储元素的数据类型> 变量名 = new ArrayList<要存储元素的数据类型>();

集合中存储的元素，只能为<>括号中指定的数据类型元素；
“<要存储元素的数据类型>”中的数据类型必须是引用数据类型，不能是基本数据类型；
下面给出8种基本数据类型所对应的引用数据类型表示形式:
基本数据类型 对应的引用数据类型表示形式


byte　　——> 　　Byte
short    ——>　　Short
Int　　——>    Integer
long    ——>　　Long
float    ——>　　Float
double    ——>　　Double
char    ——>　　Character
boolean    ——>　　Boolean

我们通过举几个例子，来明确集合的创建方式：


//存储String类型的元素
ArrayList<String> list = new ArrayList<String>();
//存储int类型的数据
ArrayList<Integer> list = new ArrayList<Integer>(); 
//存储Phone类型的数据
ArrayList<Phone> list = new ArrayList<Phone>();

集合中常用方法
接下来，我们来学习下ArrayList集合提供的一些常用方法，如下：

boolean add（Object obj）    //将指定元素obj追加到集合的末尾
Object get（int index）      //返回集合中指定位置上的元素
int size（）    　　　　　　   //返回集合中的元素个数
下面通过代码演示上述方法的使用。ArrayListDemo01.java


package arraylist;
import java.util.ArrayList;
public class ArrayListDemo01 {
    public static void main(String[] args) {
// 创建ArrayList集合
        ArrayList<String> list = new ArrayList<String>();
// 向集合中添加元素
        list.add("stu1");
        list.add("stu2");
        list.add("stu3");
        list.add("stu4");
// 获取集合中元素的个数
        System.out.println("集合的长度：" + list.size());
// 取出并打印指定位置的元素
        System.out.println("第1个元素是：" + list.get(0));
        System.out.println("第2个元素是：" + list.get(1));
        System.out.println("第3个元素是：" + list.get(2));
        System.out.println("第4个元素是：" + list.get(3));
    }
}
//集合的长度：4
//第1个元素是：stu1
//第2个元素是：stu2
//第3个元素是：stu3
//第4个元素是：stu4

强调一点，ArrayList集合相当于是一个长度可变的数组，所以访问集合中的元素也是采用索引方式访问，第一个元素存储在索引0的位置，第二个元素存储在索引1的位置，依次类推。

集合的遍历
通过集合遍历，得到集合中每个元素，这是集合中最常见的操作。集合的遍历与数组的遍历很像，都是通过索引的方式，集合遍历方式如下：ArrayListDemo02.java


package arraylist;
import java.util.ArrayList;
public class ArrayListDemo02 {
    public static void main(String[] args) {
        //创建ArrayList集合
        ArrayList<Integer> list = new ArrayList<Integer>();
        //添加元素到集合
        list.add(13);
        list.add(15);
        list.add(22);
        list.add(29);
        //遍历集合
        for (int i = 0; i < list.size(); i++) {//[获取集合中元素的个数]
            //通过索引，获取到集合中每个元素
            int n = list.get(i);//[获取集合中指定位置上的元素值];
            System.out.println(n);
        }
    }
}
//13
//15
//22
//29

上述代码中，定义了一个可以存储int元素的集合；接着实现将int类型数值存储到集合中；接着实现遍历集合元素。这里要强调一点，get方法返回值的类型为集合中元素的类型。

集合中的常用方法补充
ArrayList集合提供的一些常用方法，如下：

boolean add（int index, Object obj）      //将指定元素obj插入到集合中指定的位置
Object remove（int index）    　　　　　 　//从集合中删除指定index处的元素，返回该元素
void clear（）    　　　　　　　　　　　　   //清空集合中所有元素
Object set（int index, Object obj）      //用指定元素obj替代集合中指定位置上的元素
 

 



ASCII编码表
ASCII编码表， 英文全称 American Standard Code for Information Interchange，美国标准信息交换代码。

ASCII编码表由来
计算机中，所有的数据在存储和运算时都要使用二进制数表示
a、b、c、d这样的52个字母（包括大写）、以及0、1等数字还有一些常用的符号, 在计算机中存储时也要使用二进制数来表示， 具体用哪些二进制数字表示哪个符号，当然每个人都可以约定自己的一套（这就叫编码）。
大家如果要想互相通信而不造成混乱，那么大家就必须使用相同的编码规则，于是美国有关的标准化组织就出台了ASCII编码，统一规定了上述常用符号用哪些二进制数来表示。

中文编码表

GB2312
UNICODE
字符中重要的ASCII码对应关系

a : 97
A : 65
0 : 48
char类型的存储
short:占两个字节,是有符号数据,取值范围-32768-32767，char: 占两个字节,是无符号数据,取值范围0-65536。char类型的数据参加运算时要先转换为int数据类型。
Java基础学习笔记五 Java基础语法之面向对象
面向对象
理解什么是面向过程、面向对象
面向过程与面向对象都是我们编程中，编写程序的一种思维方式。
面向过程的程序设计方式，是遇到一件事时，思考“我该怎么做”，然后一步步实现的过程。
例如：公司打扫卫生（擦玻璃、扫地、拖地、倒垃圾等），按照面向过程的程序设计方式会思考“打扫卫生我该怎么做，然后一件件的完成”，最后把公司卫生打扫干净了。
面向对象的程序设计方式，是遇到一件事时，思考“我该让谁来做”，然后那个“谁”就是对象，他要怎么做这件事是他自己的事，反正最后一群对象合力能把事就好就行了。
例如，公司打扫卫生（擦玻璃、扫地、拖地、倒垃圾等），按照面向对象的程序设计方式会思考“我该让谁来做，如小明擦玻璃、让小丽扫地、让小郭拖地、让小强倒垃圾等”,这里的“小明、小丽、小郭、小强”就是对象，他们要打扫卫生，怎么打扫是他们自己的事，反正最后一群对象合力把公司卫生打扫干净了。

面向对象举例
买电脑（组装机）
使用面向过程说明买电脑这件事：上网查询参数和报价、电脑城询价、现场安装和监督、抱电脑回家。在整个过程中我们参与了每一个细节，并且会感觉相当累。
使用面向对象说明买电脑这件事：假如我们需要买组装机，这时应该找一个懂电脑硬件的人，让他帮我们查看参数和报价，并进行询价和杀价，以及现场组装监督。而我们自己并不需要亲历亲为具体怎么做，只要告诉这个人我们想要的具体需求即可。分析上述整个过程，发现瞬间变的十分轻松，只要找到懂电脑硬件的这个人，我们的问题都可以解决。并且在这个过程中我们不用那么辛苦。

面向对象思维方式的好处

通过生活中的真实场景使用面向对象分析完之后，我们开始分析面向过程和面向对象的差异做出总结：

面向对象思维方式是一种更符合人们思考习惯的思想
面向过程思维方式中更多的体现的是执行者（自己做事情），面向对象中更多的体现是指挥者（指挥对象做事情）。
面向对象思维方式将复杂的问题简单化。
类与对象
对象在需求中的使用
对面向对象有了了解之后，我们来说说在具体问题中如何使用面向对象去分析问题，和如何使用面向对象。
我们把大象装冰箱为例进行分析。在针对具体的需求，可以使用名词提炼的办法进行分析，寻找具体的对象。
需求：把大象装冰箱里
对象：大象、冰箱
分三步：

1、打开冰箱门
2、将大象装进去
3、关闭冰箱门
分析发现打开、装、关闭都是冰箱的功能。即冰箱对象具备如下功能：
冰箱打开
冰箱存储
冰箱关闭
用伪代码描述，上述需求中有两个具体的事物 大象 和 冰箱
描述大象：

class 大象
{
}
描述冰箱


class冰箱
{
    void 打开(){}
    void 存储(大象){}
    void 关闭(){}
}

当把具体的事物描述清楚之后，需要使用这些具体的事物，Java使用具体的事物，需要通过new关键字来创建这个事物的具体实例。

使用对象：
1、创建冰箱的对象

冰箱 bx = new 冰箱(); 
2、调用冰箱的功能

对象.功能()；
bx.打开();
bx.存储(new 大象());
bx.关闭();
总结：

1、先按照名词提炼问题领域中的对象
2、对对象进行描述，其实就是在明确对象中应该具备的属性和功能
3、通过new的方式就可以创建该事物的具体对象
4、通过该对象调用它以后的功能。

对象在代码中的体现
在分析现实生活中的事物时发现，这些事物都有其具体的特点和功能，这些特点和功能就组成了这个特殊的事物。
比如描述小汽车：

分析：
事物的特点（属性）：
颜色。
轮胎个数。
事物的(功能)：
运行。
可以发现：事物其实就是由特点（属性）和行为（功能）组成的。
可以简单理解：属性就是数值，其实就是变量；行为就是功能，就是方法。

小汽车 {
    颜色；
    轮胎个数；
    运行() {    }
}
通过计算机语言Java来描述这个事物。

定义类的格式


public class 类名 {
    //可编写0至n个属性
    数据类型 变量名1；
    数据类型 变量名2；

    //可编写0至n个方法
    修饰符 返回值类型 方法名(参数){
        执行语句;
    }
}

汽车类


public class Car {
    String color;
    int number;

    void run() {
        System.out.println(color + ":" + number);
    }
}

通过代码的描述，知道类的真正意义就是在描述事物。属性和功能统称为事物中的成员。

事物的成员分为两种：成员属性和成员功能。
成员属性在代码中的体现就是成员变量；成员功能在代码中的体现就是成员方法
把写好的代码测试一下。需要一个可以独立运行类。
创建对象的格式： 类名 对象名 = new 类名(); 
测试类


public class CarDemo {
    public static void main(String[] args) { 
/*
* 测试：Car类中的run方法。
*/
// 1,创建Car的对象。给对象起个名字。
        Car c = new Car();// c是类类型的变量。c指向了一个具体的Car类型的对象。
// 2,通过已有的对象调用该对象的功能。格式：对象.对象成员;
// 3,可以该对象的属性赋值。
        c.color = "red";
        c.number = 4;
        c.run();
    }
}

对象的内存图解



 

类和对象的区别
面向对象的编程思想力图在程序中对事物的描述与该事物在现实中的形态保持一致。为了做到这一点，面向对象的思想中提出两个概念，即类和对象。其中，类是对某一类事物的抽象描述，而对象用于表示现实中该类事物的个体。接下来通过一个图例来抽象描述类与对象的关系，如下图所示。



 


在上图中，可以将玩具模型看作是一个类，将一个个玩具看作对象，从玩具模型和玩具之间的关系便可以看出类与对象之间的关系。类用于描述多个对象的共同特征，它是对象的模板。对象用于描述现实中的个体，它是类的实例。从上图中可以明显看出对象是根据类创建的，并且一个类可以对应多个对象，接下来分别讲解什么是类和对象。
经过前面几个知识点的学习，基本上掌握了类是用于描述事物的，类中可以定义事物的属性和行为。而对象是通过描述的这个类，使用new关键字创建出来，通过对象就可以调用该对象具体的属性和功能了。

局部变量和成员变量区别
类中定义的变量，和在方法定义的变量有啥差别呢？
区别一：定义的位置不同
定义在类中的变量是成员变量；定义在方法中或者{}语句里面的变量是局部变量
区别二：在内存中的位置不同
成员变量存储在对内存的对象中；局部变量存储在栈内存的方法中
区别三：声明周期不同
成员变量随着对象的出现而出现在堆中，随着对象的消失而从堆中消失；局部变量随着方法的运行而出现在栈中，随着方法的弹栈而消失
区别四：初始化不同
成员变量因为在堆内存中，所以有默认的初始化值；局部变量没有默认的初始化值，必须手动的给其赋值才可以使用。

基本类型和引用类型作为参数传递
引用类型数据和基本类型数据作为参数传递有没有差别呢？我们用如下代码进行说明：


class Demo
{
    public static void main(String[] args)
    {
        int x = 4;
        show(x);
        System.out.println("x="+x);
    }
    public static void show(int x)
    {
        x = 5;

    }
}    

基本类型作为参数传递时，其实就是将基本类型变量x空间中的值复制了一份传递给调用的方法show()，当在show()方法中x接受到了复制的值，再在show()方法中对x变量进行操作，这时只会影响到show中的x。当show方法执行完成，弹栈后，程序又回到main方法执行，main方法中的x值还是原来的值。


class Demo
{
    int x ;
    public static void main(String[] args)
    {

        Demo d = new Demo();
        d.x = 5;
        show(d);
        System.out.println("x="+d.x);
    }
    public static void show(Demo d)
    {
        d.x = 6;
    }
}    

当引用变量作为参数传递时，这时其实是将引用变量空间中的内存地址(引用)复制了一份传递给了show方法的d引用变量。这时会有两个引用同时指向堆中的同一个对象。当执行show方法中的d.x=6时，会根据d所持有的引用找到堆中的对象，并将其x属性的值改为6.show方法弹栈。由于是两个引用指向同一个对象，不管是哪一个引用改变了引用的所指向的对象的中的值，其他引用再次使用都是改变后的值。

 

                                                                             

 

 

封装
封装概述
封装，它也是面向对象思想的特征之一。面向对象共有三个特征：封装，继承，多态。
封装表现：

方法就是一个最基本封装体。
类其实也是一个封装体。
从以上两点得出结论，封装的好处：

提高了代码的复用性。
隐藏了实现细节，还要对外提供可以访问的方式。便于调用者的使用。这是核心之一，也可以理解为就是封装的概念。
提高了安全性。
封装举例
一台电脑，它是由CPU、主板、显卡、内存、硬盘、电源等部件组长，其实我们将这些部件组装在一起就可以使用电脑了，但是发现这些部件都散落在外面，很容造成不安全因素，于是，使用机箱壳子，把这些部件都装在里面，并在机箱壳上留下一些插口等，若不留插口，大家想想会是什么情况。总结：机箱其实就是隐藏了办卡设备的细节，对外提供了插口以及开关等访问内部细节的方式。

私有private
了解到封装在生活的体现之后，又要回到Java中，细说封装的在Java代码中的体现，先从描述Person说起。


class Person {
    int age;
    String name;

    public void show() {
        System.out.println("age=" + age + ",name" + name);
    }
}

public class PersonDemo {
    public static void main(String[] args) {
// 创建Person对象
        Person p = new Person();
        p.age = -20; // 给Person对象赋值
        p.name = "人妖";
        p.show(); // 调用Person的show方法
    }
}

通过上述代码发现，虽然我们用Java代码把Person描述清楚了，但有个严重的问题，就是Person中的属性的行为可以任意访问和使用。这明显不符合实际需求。

可是怎么才能不让访问呢？需要使用一个Java中的关键字也是一个修饰符 private(私有，权限修饰符)。只要将Person的属性和行为私有起来，这样就无法直接访问。


class Person {
    private int age;
    private String name;

    public void show() {
        System.out.println("age=" + age + ",name" + name);
    }
}

年龄已被私有，错误的值无法赋值，可是正确的值也赋值不了，这样还是不行，那肿么办呢？按照之前所学习的封装的原理，隐藏后，还需要提供访问方式。只要对外提供可以访问的方法，让其他程序访问这些方法。同时在方法中可以对数据进行验证。

一般对成员属性的访问动作：赋值(设置 set)，取值(获取 get)，因此对私有的变量访问的方式可以提供对应的 setXxx或者getXxx的方法。


class Person {
    // 私有成员变量
    private int age;
    private String name;

    // 对外提供设置成员变量的方法
    public void setAge(int a) {
// 由于是设置成员变量的值，这里可以加入数据的验证
        if (a < 0 || a > 130) {
            System.out.println(a + "不符合年龄的数据范围");
            return;
        }
        age = a;
    }

    // 对外提供访问成员变量的方法
    public void getAge() {
        return age;
    }
}

总结：类中不需要对外提供的内容都私有化，包括属性和方法。以后再描述事物，属性都私有化，并提供setXxx getXxx方法对其进行访问。注意：私有仅仅是封装的体现形式而已。

this关键字
成员变量和局部变量同名问题，当在方法中出现了局部变量和成员变量同名的时候，那么在方法中怎么区别局部变量成员变量呢？可以在成员变量名前面加上this，来区别成员变量和局部变量。


class Person {
    private int age;
    private String name;

    public void speak() {
        this.name = "小强";
        this.age = 18;
        System.out.println("name=" + this.name + ",age=" + this.age);
    }
}
class PersonDemo {
    public static void main(String[] args) {
        Person p = new Person();
        p.speak();
    }
}

对象的内存解释
我们已经学习了如何把生活中的事物使用Java代码描述，接下来我们分析对象在内存中的分配情况。这里需要画图一步一步演示，严格按照画图流程讲解内存对象创建使用过程。


class Person {
    private int age;
    public int getAge() {
        return this.age;
    }
    public void setAge(int age) {
        this.age = age;
    }
}
public class PersonDemo {
    public static void main(String[] args) {
        Person p = new Person();
        p.setAge(30);
        System.out.println("大家好，今年我" + p.getAge() + "岁");
    }
}

下图为程序中内存对象的创建使用过程。



程序执行流程说明：

1、先执行main方法（压栈），执行其中的 Person p = new Person()；
2、在堆内存中开辟空间，并为其分配内存地址0x1234，紧接着成员变量默认初始化(age = 0)；将内存地址0x1234赋值给栈内中的Person p 变量
3、继续执行p.setAge(30)语句，这时会调用setAge(int age)方法，将30赋值为setAge方法中的“age”变量；执行this.age = age语句，将age变量值30 赋值给成员变量this.age为30；
4、setAge()方法执行完毕后（弹栈），回到main()方法，执行输出语句System.out.println()，控制台打印p对象中的age年龄值。
注意：
this到底代表什么呢？this代表的是对象，具体代表哪个对象呢？哪个对象调用了this所在的方法，this就代表哪个对象。
上述代码中的 p.setAge(30)语句中，setAge(int age)方法中的this代表的就是p对象。
this的应用
学习this的用法之后，现在做个小小的练习。需求：在Person类中定义功能，判断两个人是否是同龄人。

Java基础学习笔记七 Java基础语法之继承和抽象类
继承
继承的概念
在现实生活中，继承一般指的是子女继承父辈的财产。在程序中，继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系。

例如公司中的研发部员工和维护部员工都属于员工，程序中便可以描述为研发部员工和维护部员工继承自员工，同理，JavaEE工程师和Android工程师继承自研发部员工，而维网络维护工程师和硬件维护工程师继承自维护部员工。这些员工之间会形成一个继承体系，具体如下图所示。



在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承的属性和方法。

继承的格式&使用
在程序中，如果想声明一个类继承另一个类，需要使用extends关键字。
格式：class 子类 extends 父类 {}
接下来通过一个案例来学习子类是如何继承父类的，如下所示。Employee .java


/*
* 定义员工类Employee
*/
public class Employee {
    String name; // 定义name属性
    // 定义员工的工作方法
    public void work() {
        System.out.println("尽心尽力地工作");
    }
}


/*
* 定义研发部员工类Developer 继承 员工类Employee
*/
class Developer extends Employee {
    // 定义一个打印name的方法
    public void printName() {
        System.out.println("name=" + name);
    }
}


* 定义测试类
*/
public class Example01 {
    public static void main(String[] args) {
        Developer d = new Developer(); // 创建一个研发部员工类对象
        d.name = "小明"; // 为该员工类的name属性进行赋值
        d.printName(); // 调用该员工的printName()方法
        d.work(); // 调用Developer类继承来的work()方法
    }
}

运行结果如下图所示。



在上述代码中，Developer类通过extends关键字继承了Employee类，这样Developer类便是Employee类的子类。从运行结果不难看出，子类虽然没有定义name属性和work()方法，但是却能访问这两个成员。这就说明，子类在继承父类的时候，会自动拥有父类的成员。

继承的好处&注意事项
继承的好处：

继承的出现提高了代码的复用性，提高软件开发效率。
继承的出现让类与类之间产生了关系，提供了多态的前提。
在类的继承中，需要注意一些问题，具体如下：
1、在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类，例如下面这种情况是不合法的。

class A{} 
class B{}
class C extends A,B{} // C类不可以同时继承A类和B类
2、多个类可以继承一个父类，例如下面这种情况是允许的。

class A{}
class B extends A{}
class C extends A{} // 类B和类C都可以继承类A
3、在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类，例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类。下面这种情况是允许的。

class A{}
class B extends A{} // 类B继承类A，类B是类A的子类
class C extends B{} // 类C继承类B，类C是类B的子类，同时也是类A的子类
4、在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。例如上面的这种情况中，B类是A类的子类，同时又是C类的父类。

继承-子父类中成员变量的特点
了解了继承给我们带来的好处，提高了代码的复用性。继承让类与类或者说对象与对象之间产生了关系。那么，当继承出现后，类的成员之间产生了那些变化呢？
成员变量：如果子类父类中出现不同名的成员变量，这时的访问是没有任何问题。
看如下代码：


class Fu
{
    //Fu中的成员变量。
    int num = 5;
}
class Zi extends Fu
{
    //Zi中的成员变量
    int num2 = 6;
    //Zi中的成员方法
    public void show()
    {
//访问父类中的num
        System.out.println("Fu num="+num);
//访问子类中的num2
        System.out.println("Zi num2="+num2);
    }
}
class Demo
{
    public static void main(String[] args)
    {
        Zi z = new Zi(); //创建子类对象
        z.show(); //调用子类中的show方法
    }
}

代码说明：Fu类中的成员变量是非私有的，子类中可以直接访问，若Fu类中的成员变量私有了，子类是不能直接访问的。

当子父类中出现了同名成员变量时，在子类中若要访问父类中的成员变量，必须使用关键字super来完成。super用来表示当前对象中包含的父类对象空间的引用。
在子类中，访问父类中的成员变量格式： super.父类中的成员变量 
看如下代码：


class Fu
{
    //Fu中的成员变量。
    int num = 5;
}
class Zi extends Fu
{
    //Zi中的成员变量
    int num = 6;
    void show()
    {
//子父类中出现了同名的成员变量时
//在子类中需要访问父类中非私有成员变量时，需要使用super关键字
//访问父类中的num
        System.out.println("Fu num="+super.num);
//访问子类中的num2
        System.out.println("Zi num2="+this.num);
    }
}
class Demo5
{
    public static void main(String[] args)
    {
        Zi z = new Zi(); //创建子类对象
        z.show(); //调用子类中的show方法
    }
}

继承-子父类中成员方法特点-重写&应用
子父类中成员方法的特点
当在程序中通过对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。
看如下代码：


class Fu{
    public void show(){
        System.out.println("Fu类中的show方法执行");
    }
}
class Zi extends Fu{
    public void show2(){
        System.out.println("Zi类中的show2方法执行");
    }
}
public class Test{
    public static void main(String[] args) {
        Zi z = new Zi();
        z.show(); //子类中没有show方法，但是可以找到父类方法去执行
        z.show2();
    }
}

成员方法特殊情况——覆盖
子类中出现与父类一模一样的方法时，会出现覆盖操作，也称为override重写、复写或者覆盖。


class Fu
{
    public void show()
    {
        System.out.println("Fu show");
    }
}
class Zi extends Fu
{
    //子类复写了父类的show方法
    public void show()
    {
        System.out.println("Zi show");
    }
}

方法重写（覆盖）的应用
当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容。
举例：比如手机，当描述一个手机时，它具有发短信，打电话，显示来电号码功能，后期由于手机需要在来电显示功能中增加显示姓名和头像，这时可以重新定义一个类描述智能手机，并继承原有描述手机的类。并在新定义的类中覆盖来电显示功能，在其中增加显示姓名和头像功能。
在子类中，访问父类中的成员方法格式： super.父类中的成员方法(); 
看如下代码：


//手机类
class Phone{
    public void sendMessage(){
        System.out.println("发短信");
    }
    public void call(){
        System.out.println("打电话");
    }
    public void showNum(){
        System.out.println("来电显示号码");
    }
}

//智能手机类
class NewPhone extends Phone{

    //覆盖父类的来电显示号码功能，并增加自己的显示姓名和图片功能
    public void showNum(){
//调用父类已经存在的功能使用super
        super.showNum();
//增加自己特有显示姓名和图片功能
        System.out.println("显示来电姓名");
        System.out.println("显示头像");
    }
}

方法重写的注意事项
重写需要注意的细节问题：子类方法覆盖父类方法，必须要保证权限大于等于父类权限。


class Fu(){
    void show(){}
    public void method(){}
}
class Zi() extends Fu{
    public void show(){} //编译运行没问题
        void method(){} //编译错误
}

写法上稍微注意:必须一模一样:方法的返回值类型 方法名 参数列表都要一样。

总结：当一个类是另一个类中的一种时，可以通过继承，来继承属性与功能。如果父类具备的功能内容需要子类特殊定义时，进行方法重写。

不能为了继承某个功能而随意进行继承操作， 必须要符合 is a 的关系

苹果 is a 水果
男人 is a 人
狗 is a 人 ， 这种情况就不能继承了
重载与重写对比
重载
权限修饰符(public private 默认):无关
方法名:重载的两个方法的方法名必须相同
形参列表:

形参类型的顺序不同
形参的个数不同
形参的类型不同
三者至少满足一个
返回值类型:重载与返回值类型无关

重写
权限修饰符(public private 默认): 子类方法的权限>=父类的方法的权限
方法名: 子类方法和父类方法必须相同
形参列表: 子类方法和父类方法的形参列表必须相同
返回值类型:基本类数据类型:必须相同
引用数据类型:子类方法的返回值类型和父类方法的返回值类型相同，或者子类方法的返回值类型是父类方法的返回值类型的 子类

抽象类
抽象类-产生
当编写一个类时，我们往往会为该类定义一些方法，这些方法是用来描述该类的功能具体实现方式，那么这些方法都有具体的方法体。但是有的时候，某个父类只是知道子类应该包含怎么样的方法，但是无法准确知道子类如何实现这些方法。比如一个图形类应该有一个求周长的方法，但是不同的图形求周长的算法不一样。那该怎么办呢？
分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是方法功能声明相同，但方法功能主体不同。那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么此方法就是一个抽象方法。
描述JavaEE工程师：行为：工作。
描述Android工程师：行为：工作。
JavaEE工程师和Android工程师之间有共性，可以进行向上抽取。抽取它们的所属共性类型：研发部员工。由于JavaEE工程师和Android工程师都具有工作功能，但是他们具体工作内容却不一样。这时在描述研发部员工时，发现了有些功能（工作）不具体，这些不具体的功能，需要在类中标识出来，通过java中的关键字abstract(抽象)。
当定义了抽象函数的类也必须被abstract关键字修饰，被abstract关键字修饰的类是抽象类。

抽象类&抽象方法的定义
抽象方法定义的格式：

public abstract 返回值类型 方法名(参数);
    抽象类定义的格式：
    abstract class 类名 {
}
看如下代码：


//研发部员工 
abstract class Developer {
    public abstract void work();//抽象函数。需要abstract修饰，并分号;结束
}

//JavaEE工程师
class JavaEE extends Developer{
    public void work() {
        System.out.println("正在研发淘宝网站");
    }
}


//Android工程师

class Android extends Developer {
    public void work() {
        System.out.println("正在研发淘宝手机客户端软件");
    }
}

抽象类的特点
1、抽象类和抽象方法都需要被abstract修饰。抽象方法一定要定义在抽象类中。
2、抽象类不可以直接创建对象，原因：调用抽象方法没有意义。
3、只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象。否则该子类还是一个抽象类。
之所以继承抽象类，更多的是在思想，是面对共性类型操作会更简单。

抽象类的细节问题：
1、抽象类一定是个父类？ 是的，因为不断抽取而来的。
2、抽象类中是否可以不定义抽象方法。是可以的，那这个抽象类的存在到底有什么意义呢？不让该类创建对象,方法可以直接让子类去使用
3、抽象关键字abstract不可以和哪些关键字共存？

private：私有的方法子类是无法继承到的，也不存在覆盖，而abstract和private一起使用修饰方法，abstract既要子类去实现这个方法，而private修饰子类根本无法得到父类这个方法。互相矛盾。
final，暂时不关注，后面学
static，暂时不关注，后面学
综合案例---员工类系列定义
案例介绍
某IT公司有多名员工，按照员工负责的工作不同，进行了部门的划分（研发部员工、维护部员工）。研发部根据所需研发的内容不同，又分为JavaEE工程师、Android工程师；维护部根据所需维护的内容不同，又分为网络维护工程师、硬件维护工程师。
公司的每名员工都有他们自己的员工编号、姓名，并要做它们所负责的工作。

工作内容

JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站
Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件
网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通
硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机
请根据描述，完成员工体系中所有类的定义，并指定类之间的继承关系。进行XX工程师类的对象创建，完成工作方法的调用。

案例分析
根据上述部门的描述，得出如下的员工体系图



根据员工信息的描述，确定每个员工都有员工编号、姓名、要进行工作。则，把这些共同的属性与功能抽取到父类中（员工类），关于工作的内容由具体的工程师来进行指定。

案例代码实现
根据员工体系图，完成类的定义
定义员工类(抽象类)


public abstract class Employee {
    private String id;// 员工编号
    private String name; // 员工姓名

    public String getId() {
        return id;
    }
    public void setId(String id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }

    //工作方法（抽象方法）
    public abstract void work();
}

定义研发部员工类Developer 继承 员工类Employee

public abstract class Developer extends Employee {
}
定义维护部员工类Maintainer 继承 员工类Employee

public abstract class Maintainer extends Employee {
}
定义JavaEE工程师 继承 研发部员工类，重写工作方法


public class JavaEE extends Developer {
    @Override
    public void work() {
        System.out.println("员工号为 " + getId() + " 的 " + getName() + " 员工，正在研发淘宝网站");
    }
}

定义Android工程师 继承 研发部员工类，重写工作方法


public class Android extends Developer {
    @Override
    public void work() {
        System.out.println("员工号为 " + getId() + " 的 " + getName() + " 员工，正在研发淘宝手机客户端软件");
    }
}

定义Network网络维护工程师 继承 维护部员工类，重写工作方法


public class Network extends Maintainer {
    @Override
    public void work() {
        System.out.println("员工号为 " + getId() + " 的 " + getName() + " 员工，正在检查网络是否畅通");
    }
}

定义Hardware硬件维护工程师 继承 维护部员工类，重写工作方法


public class Hardware extends Maintainer {
    @Override
    public void work() {
        System.out.println("员工号为 " + getId() + " 的 " + getName() + " 员工，正在修复打印机");
    }
}

在测试类中，创建JavaEE工程师对象，完成工作方法的调用


public class Test {
    public static void main(String[] args) {
//创建JavaEE工程师员工对象
        JavaEE ee = new JavaEE();
//设置该员工的编号
        ee.setId("000015");
//设置该员工的姓名
        ee.setName("小明");
//调用该员工的工作方法
        ee.work();
    }
}
Java基础学习笔记八 Java基础语法之接口和多态
接口
接口概念
接口是功能的集合，同样可看做是一种数据类型，是比抽象类更为抽象的”类”。
接口只描述所应该具备的方法，并没有具体实现，具体的实现由接口的实现类(相当于接口的子类)来完成。这样将功能的定义与实现分离，优化了程序设计。
请记住：一切事物均有功能，即一切事物均有接口。

接口的定义
与定义类的class不同，接口定义时需要使用interface关键字。
定义接口所在的仍为.java文件，虽然声明时使用的为interface关键字的编译后仍然会产生.class文件。这点可以让我们将接口看做是一种只包含了功能声明的特殊类。
定义格式：

public interface 接口名 {
    抽象方法1;
    抽象方法2;
    抽象方法3;
}
使用interface代替了原来的class，其他步骤与定义类相同：

接口中的方法均为公共访问的抽象方法
接口中无法定义普通的成员变量
类实现接口
类与接口的关系为实现关系，即类实现接口。实现的动作类似继承，只是关键字不同，实现使用implements。
其他类(实现类)实现接口后，就相当于声明：”我应该具备这个接口中的功能”。实现类仍然需要重写方法以实现具体的功能。
格式：

class 类 implements 接口 {
    重写接口中方法
} 
在类实现接口后，该类就会将接口中的抽象方法继承过来，此时该类需要重写该抽象方法，完成具体的逻辑。

接口中定义功能，当需要具有该功能时，可以让类实现该接口，只声明了应该具备该方法，是功能的声明。在具体实现类中重写方法，实现功能，是方法的具体实现。于是，通过以上两个动作将功能的声明与实现便分开了。

接口中成员的特点
接口中可以定义变量，但是变量必须有固定的修饰符修饰，public static final，所以接口中的变量也称之为常量，其值不能改变。后面我们会讲解static与final关键字
接口中可以定义方法
接口不可以创建对象
子类必须覆盖掉接口中所有的方法后，子类才可以实例化。否则子类是一个抽象类。
class DemoImpl implements Demo { //子类实现Demo接口。
    //重写接口中的方法。
    public void show1(){}
    public void show2(){}
}
接口的多实现
了解了接口的特点后，那么想想为什么要定义接口，使用抽象类描述也没有问题，接口到底有啥用呢？接口最重要的体现：解决多继承的弊端。将多继承这种机制在java中通过多实现完成了。


interface Fu1
{
    void show1();
}
interface Fu2
{
    void show2();
}
class Zi implements Fu1,Fu2// 多实现。同时实现多个接口。
{
    public void show1(){}
    public void show2(){}
}

怎么解决多继承的弊端呢？

弊端：多继承时，当多个父类中有相同功能时，子类调用会产生不确定性。其实核心原因就是在于多继承父类中功能有主体，而导致调用运行时，不确定运行哪个主体内容。为什么多实现能解决了呢？因为接口中的功能都没有方法体，由子类来明确。

类继承类同时实现接口
接口和类之间可以通过实现产生关系，同时也学习了类与类之间可以通过继承产生关系。当一个类已经继承了一个父类，它又需要扩展额外的功能，这时接口就派上用场了。
子类通过继承父类扩展功能，通过继承扩展的功能都是子类应该具备的基础功能。如果子类想要继续扩展其他类中的功能呢？这时通过实现接口来完成。


class Fu {
    public void show(){}
}
interface Inter {
    pulbic abstract void show1();
}
class Zi extends Fu implements Inter {
    public void show1() {
    }
}

接口的出现避免了单继承的局限性。父类中定义的事物的基本功能。接口中定义的事物的扩展功能。

接口的多继承
多个接口之间可以使用extends进行继承。


interface Fu1{
    void show();
}
interface Fu2{
    void show1();
}
interface Fu3{
    void show2();
}
interface Zi extends Fu1,Fu2,Fu3{
    void show3();
}

在开发中如果多个接口中存在相同方法，这时若有个类实现了这些接口，那么就要实现接口中的方法，由于接口中的方法是抽象方法，子类实现后也不会发生调用的不确定性。

接口的思想
前面学习了接口的代码体现，现在来学习接口的思想，接下里从生活中的例子进行说明。
举例：我们都知道电脑上留有很多个插口，而这些插口可以插入相应的设备，这些设备为什么能插在上面呢？主要原因是这些设备在生产的时候符合了这个插口的使用规则，否则将无法插入接口中，更无法使用。发现这个插口的出现让我们使用更多的设备。
总结：接口在开发中的它好处

1、接口的出现扩展了功能。
2、接口其实就是暴漏出来的规则。
3、接口的出现降低了耦合性，即设备与设备之间实现了解耦。
接口的出现方便后期使用和维护，一方是在使用接口（如电脑），一方在实现接口（插在插口上的设备）。例如：笔记本使用这个规则（接口），电脑外围设备实现这个规则（接口）。

接口和抽象的区别
犬分为很多种类，他们吼叫和吃饭的方式不一样，在描述的时候不能具体化，也就是吼叫和吃饭的行为不能明确。当描述行为时，行为的具体动作不能明确，这时，可以将这个行为写为抽象行为，那么这个类也就是抽象类。

可是当缉毒犬有其他额外功能时，而这个功能并不在这个事物的体系中。这时可以让缉毒犬具备犬科自身特点的同时也有其他额外功能，可以将这个额外功能定义接口中。
如下代码演示：


interface 缉毒{
    public abstract void 缉毒();
}
//定义犬科的这个提醒的共性功能
abstract class 犬科{
    public abstract void 吃饭();
    public abstract void 吼叫();
}
// 缉毒犬属于犬科一种，让其继承犬科，获取的犬科的特性，

//由于缉毒犬具有缉毒功能，那么它只要实现缉毒接口即可，这样即保证缉毒犬具备犬科的特性，也拥有了缉毒的功能
class 缉毒犬 extends 犬科 implements 缉毒{

    public void 缉毒() {
    }
    void 吃饭() {
    }
    void 吼叫() {
    }
}
class 缉毒猪 implements 缉毒{
    public void 缉毒() {
    }
}

通过上面的例子总结接口和抽象类的区别：

相同点:

都位于继承的顶端,用于被其他类实现或继承;
都不能直接实例化对象;
都包含抽象方法,其子类都必须覆写这些抽象方法;
区别:

抽象类为部分方法提供实现,避免子类重复实现这些方法,提高代码重用性;接口只能包含抽象方法;
一个类只能继承一个直接父类(可能是抽象类),却可以实现多个接口;(接口弥补了Java的单继承)
抽象类是这个事物中应该具备的内容, 继承体系是一种 is..a关系
接口是这个事物中的额外内容,继承体系是一种 like..a关系
二者的选用:
优先选用接口,尽量少用抽象类;
需要定义子类的行为,又要为子类提供共性功能时才选用抽象类;

多态
多态是继封装、继承之后，面向对象的第三大特性。现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。
Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。
Java中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。
如Student类可以为Person类的子类。那么一个Student对象既可以赋值给一个Student类型的引用，也可以赋值给一个Person类型的引用。

最终多态体现为父类引用变量可以指向子类对象。
多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。
在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。
多态的定义与使用格式
多态的定义格式：就是父类的引用变量指向子类对象

父类类型 变量名 = new 子类类型();
变量名.方法名();
普通类多态定义的格式

父类 变量名 = new 子类();
如：    class Fu {}
class Zi extends Fu {}
//类的多态使用
Fu f = new Zi();
抽象类多态定义的格式

抽象类 变量名 = new 抽象类子类();
比如：


abstract class Fu {
    public abstract void method();
}
class Zi extends Fu {
    public void method(){
        System.out.println("重写父类抽象方法");
    }
}
//类的多态使用
Fu fu= new Zi();

接口多态定义的格式

接口 变量名 = new 接口实现类();
比如：


interface Fu {
    public abstract void method();
}
class Zi implements Fu {
    public void method(){
        System.out.println("重写接口抽象方法");
    }
}
//接口的多态使用
Fu fu = new Zi();

注意事项
同一个父类的方法会被不同的子类重写。在调用方法时，调用的为各个子类重写后的方法。

Person p1 = new Student();
Person p2 = new Teacher();
p1.work(); //p1会调用Student类中重写的work方法
p2.work(); //p2会调用Teacher类中重写的work方法
当变量名指向不同的子类对象时，由于每个子类重写父类方法的内容不同，所以会调用不同的方法。

多态-成员的特点
多态出现后会导致子父类中的成员变量有微弱的变化。看如下代码


class Fu {
    int num = 4;
}
class Zi extends Fu {
    int num = 5;
}
class Demo {
    public static void main(String[] args) {
        Fu f = new Zi();
        System.out.println(f.num);//4
        Zi z = new Zi();
        System.out.println(z.num);//5
    }
}

多态成员变量

当子父类中出现同名的成员变量时，多态调用该变量时：
编译时期：参考的是引用型变量所属的类中是否有被调用的成员变量。没有，编译失败。
运行时期：也是调用引用型变量所属的类中的成员变量。
简单记：编译和运行都参考等号的左边。编译运行看左边。

多态出现后会导致子父类中的成员方法有微弱的变化。看如下代码


class Fu {
    int num = 4;
    void show()    {
        System.out.println("Fu show num");
    }
}
class Zi extends Fu {
    int num = 5;
    void show()    {
        System.out.println("Zi show num");
    }
}
class Demo {
    public static void main(String[] args) {
        Fu f = new Zi();
        f.show();
    }
}

多态成员方法

编译时期：参考引用变量所属的类，如果没有类中没有调用的方法，编译失败。
运行时期：参考引用变量所指的对象所属的类，并运行对象所属类中的成员方法。
简而言之：编译看左边，运行看右边。

instanceof关键字
我们可以通过instanceof关键字来判断某个对象是否属于某种数据类型。如学生的对象属于学生类，学生的对象也属于人类。
使用格式：

boolean b = 对象 instanceof 数据类型;
如

Person p1 = new Student(); // 前提条件，学生类已经继承了人类
boolean flag = p1 instanceof Student; //flag结果为true
boolean flag2 = p2 instanceof Teacher; //flag结果为false
多态-转型
多态的转型分为向上转型与向下转型两种：
向上转型：当有子类对象赋值给一个父类引用时，便是向上转型，多态本身就是向上转型的过程。
使用格式：父类类型 变量名 = new 子类类型(); 如：Person p = new Student();
向下转型：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用转为子类引用，这个过程是向下转型。如果是直接创建父类对象，是无法向下转型的！
使用格式：子类类型 变量名 = (子类类型) 父类类型的变量; 如:Student stu = (Student) p; //变量p 实际上指向Student对象

多态的好处与弊端
当父类的引用指向子类对象时，就发生了向上转型，即把子类类型对象转成了父类类型。向上转型的好处是隐藏了子类类型，提高了代码的扩展性。
但向上转型也有弊端，只能使用父类共性的内容，而无法使用子类特有功能，功能有限制。看如下代码


//描述动物类，并抽取共性eat方法
abstract class Animal {
    abstract void eat();
}

// 描述狗类，继承动物类，重写eat方法，增加lookHome方法
class Dog extends Animal {
    void eat() {
        System.out.println("啃骨头");
    }

    void lookHome() {
        System.out.println("看家");
    }
}

// 描述猫类，继承动物类，重写eat方法，增加catchMouse方法
class Cat extends Animal {
    void eat() {
        System.out.println("吃鱼");
    }

    void catchMouse() {
        System.out.println("抓老鼠");
    }
}

public class Test {
    public static void main(String[] args) {
        Animal a = new Dog(); //多态形式，创建一个狗对象
        a.eat(); // 调用对象中的方法，会执行狗类中的eat方法
// a.lookHome();//使用Dog类特有的方法，需要向下转型，不能直接使用

// 为了使用狗类的lookHome方法，需要向下转型
// 向下转型过程中，可能会发生类型转换的错误，即ClassCastException异常
// 那么，在转之前需要做健壮性判断 
        if( !a instanceof Dog){ // 判断当前对象是否是Dog类型
            System.out.println("类型不匹配，不能转换");
            return;
        }
        Dog d = (Dog) a; //向下转型
        d.lookHome();//调用狗类的lookHome方法
    }
}

我们来总结一下：

什么时候使用向上转型：当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作，这时就可以使用向上转型。

如：

Animal a = new Dog();
a.eat();
什么时候使用向下转型：当要使用子类特有功能时，就需要使用向下转型。如：

Dog d = (Dog) a; //向下转型
d.lookHome();//调用狗类的lookHome方法
向下转型的好处：可以使用子类特有功能。

弊端是：需要面对具体的子类对象；在向下转型时容易发生ClassCastException类型转换异常。在转换之前必须做类型判断。如： if( !a instanceof Dog){…} 

 

总结下封装、继承、多态的作用：
封装：把对象的属性与方法的实现细节隐藏，仅对外提供一些公共的访问方式。
继承：子类会自动拥有父类所有可继承的属性和方法。
多态：配合继承与方法重写提高了代码的复用性与扩展性；如果没有方法重写，则多态同样没有意义。多态的成员访问特点：方法的运行看右边，其他都看左边

类与类，类与接口，接口与接口之间的关系
类与类之间：继承关系，单继承，可以是多层继承
类与接口之间: 实现关系，单实现，也可以多实现
接口与接口之间：继承关系，单继承，也可以是多继承
Java中的类可以继承一个父类的同时，实现多个接口

笔记本电脑案例
案例介绍

定义USB接口（具备开启功能、关闭功能），笔记本要使用USB设备，即笔记本在生产时需要预留可以插入USB设备的USB接口，即就是笔记本具备使用USB设备的功能，但具体是什么USB设备，笔记本并不关心，只要符合USB规格的设备都可以。鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守USB规范，不然鼠标和键盘的生产出来无法使用。
进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘
USB接口，包含开启功能、关闭功能
笔记本类，包含运行功能、关机功能、使用USB设备功能
鼠标类，要符合USB接口
键盘类，要符合USB接口

案例需求分析

阶段一：使用笔记本，笔记本有运行功能，需要笔记本对象来运行这个功能
阶段二：想使用一个鼠标，又有一个功能使用鼠标，并多了一个鼠标对象。
阶段三：还想使用一个键盘 ，又要多一个功能和一个对象
问题：每多一个功能就需要在笔记本对象中定义一个方法，不爽，程序扩展性极差。
降低鼠标、键盘等外围设备和笔记本电脑的耦合性。

实现代码步骤

定义鼠标、键盘，笔记本三者之间应该遵守的规则

interface USB {
    void open();// 开启功能
    void close();// 关闭功能
}
鼠标实现USB规则


class Mouse implements USB {
    public void open() {
        System.out.println("鼠标开启");
    }

    public void close() {
        System.out.println("鼠标关闭");
    }
}

键盘实现USB规则


class KeyBoard implements USB {
    public void open() {
        System.out.println("键盘开启");
    }

    public void close() {
        System.out.println("键盘关闭");
    }
}

定义笔记本


class NoteBook {
    // 笔记本开启运行功能
    public void run() {
        System.out.println("笔记本运行");
    }

    // 笔记本使用usb设备，这时当笔记本对象调用这个功能时，必须给其传递一个符合USB规则的USB设备
    public void useUSB(USB usb) {
        // 判断是否有USB设备
        if (usb != null) {
            usb.open();
            usb.close();
        }
    }

    public void shutDown() {
        System.out.println("笔记本关闭");
    }
}

public class Test {
    public static void main(String[] args) {
// 创建笔记本实体对象
        NoteBook nb = new NoteBook();
// 笔记本开启
        nb.run();
// 创建鼠标实体对象
        Mouse m = new Mouse();
// 笔记本使用鼠标
        nb.useUSB(m);
// 创建键盘实体对象
        KeyBoard kb = new KeyBoard();
// 笔记本使用键盘
        nb.useUSB(kb);
// 笔记本关闭
        nb.shutDown();
    }
}
Java基础学习笔记九 Java基础语法之this和super
构造方法
我们对封装已经有了基本的了解，接下来我们来看一个新的问题，依然以Person为例，由于Person中的属性都被private了，外界无法直接访问属性，必须对外提供相应的set和get方法。当创建Person对象的时候，Person对象一创建就要明确其姓名和年龄，那该怎么做呢？

构造方法介绍
在开发中经常需要在创建对象的同时明确对象的属性值，比如员工入职公司就要明确他的姓名、年龄等属性信息。也就是在创建对象的时候就要做的事情，当使用new关键字创建对象时，怎么给对象的属性初始化值呢？这就要学习Java另外一门小技术，构造方法。
那什么是构造方法呢？从字面上理解就是对象创建时要执行的方法。既然是对象创建时要执行的方法，那么只要在new对象时，知道其执行的构造方法是什么，就可以在执行这个方法的时候给对象进行属性赋值。

构造方法的格式：

修饰符 构造方法名(参数列表)
{
}
构造方法的体现
构造方法没有返回值类型。也不需要写返回值。因为它是为构建对象的，对象创建完，方法就执行结束。
构造方法名称必须和类型保持一致。
构造方法没有具体的返回值。
构造方法的代码体现：


class Person {
    // Person的成员属性age和name
    private int age;
    private String name;

    // Person的构造方法，拥有参数列表
    Person(int a, String nm) {
    // 接受到创建对象时传递进来的值，将值赋给成员属性
        age = a;
        name = nm;
    }
}

构造方法调用和内存图解
理解构造方法的格式和基本功能之后，现在就要研究构造方法是怎么执行的呢？在创建对象的时候是如何初始化的呢？构造方法是专门用来创建对象的，也就是在new对象时要调用构造方法。现在来看看如何调用构造方法。


class Person {
    // Person的成员属性age和name
    private int age;
    private String name;

    // Person的构造方法，拥有参数列表
    Person(int a, String nm) {
    // 接受到创建对象时传递进来的值，将值赋给成员属性
        age = a;
        name = nm;
    }

    public void speak() {
        System.out.println("name=" + name + ",age=" + age);
    }
}

class PersonDemo {
    public static void main(String[] args) {
    // 创建Person对象，并明确对象的年龄和姓名
        Person p2 = new Person(23, "张三");
        p2.speak();
    }
}

上述代码演示了创建对象时构造方法的调用。即在创建对象时，会调用与参数列表对应的构造方法。

上述代码的图解：



图解说明：

1、首先会将main方法压入栈中，执行main方法中的 new Person(23,"张三");
2、在堆内存中分配一片区域，用来存放创建的Person对象，这片内存区域会有属于自己的内存地址（0x88）。然后给成员变量进行默认初始化（name=null，age=0）。
3、执行构造方法中的代码（age = a ; name = nm;）,将变量a对应的23赋值给age，将变量nm对应的”张三赋值给name，这段代码执行结束后，成员变量age和name的值已经改变。执行结束之后构造方法弹栈，Person对象创建完成。将Person对象的内存地址0x88赋值给p2。
默认构造方法和细节
如果没有显示指定构造方法，当在编译Java文件时，编译器会自动给class文件中添加默认的构造方法。如果在描述类时，我们显示指定了构造方法，那么，当在编译Java源文件时，编译器就不会再给class文件中添加默认构造方法。

class Person {
//如果没有显示指定构造方法，编译会在编译时自动添加默认的构造方法
//Person(){} //空参数的默认构造方法
}
当在描述事物时，要不要在类中写构造方法呢？这时要根据描述事物的特点来确定，当描述的事物在创建其对象时就要明确属性的值，这时就需要在定义类的时候书写带参数的构造方法。若创建对象时不需要明确具体的数据，这时可以不用书写构造方法（不书写也有默认的构造方法）。

构造方法的细节：

1、一个类中可以有多个构造方法，多个构造方法是以重载的形式存在的
2、构造方法是可以被private修饰的，作用：其他程序无法创建该类的对象。

class Person {
    private int age;
    private String name;

    // 私有无参数的构造方法，即外界不能通过new Person();语句创建本类对象
    private Person() {
    }

    // 多个构造方法是以重载的形式存在
    Person(int a) {
        age = a;
    }

    Person(String nm, int a) {
        name = nm;
        age = a;
    }
}

构造方法和一般方法区别
构造方法在对象创建时就执行了，而且只执行一次。一般方法是在对象创建后，需要使用时才被对象调用，并可以被多次调用。
问题：有了构造方法之后可以对对象的属性进行初始化，那么还需要对应的set和get方法吗？需要相应的set和get方法，因为对象在创建之后需要修改和访问相应的属性值时，在这时只能通过set或者get方法来操作。
思考，如下代码有问题吗？


class Person {
    void Person() {//void有问题
    }
}

class PersonDemo {
    public static void main(String[] args) {
        Person p = new Person();
    }
}

this关键字
在之前学习方法时，我们知道方法之间是可以相互调用的，那么构造方法之间能不能相互调用呢？若可以，怎么调用呢？

this调用构造方法
在之前学习方法之间调用时，可以通过方法名进行调用。可是针对构造方法，无法通过构造方法名来相互调用。构造方法之间的调用，可以通过this关键字来完成。
构造方法调用格式：

this(参数列表);
构造方法的调用


class Person {
    // Person的成员属性
    private int age;
    private String name;

    // 无参数的构造方法
    Person() {
    }

    // 给姓名初始化的构造方法
    Person(String nm) {
        name = nm;
    }

    // 给姓名和年龄初始化的构造方法
    Person(String nm, int a) {
    // 由于已经存在给姓名进行初始化的构造方法 name = nm;因此只需要调用即可
    // 调用其他构造方法，需要通过this关键字来调用
        this(nm);
    // 给年龄初始化
        age = a;
    }
}

this的原理图解
了解了构造方法之间是可以相互调用，那为什么他们之间通过this就可以调用呢？通过上面的学习，简单知道使用this可以实现构造方法之间的调用，但是为什么就会知道this调用哪一个构造方法呢？接下来需要图解完成。


class Person {
    private int age;
    private String name;

    Person() {
    }
    Person(String nm) {
        name = nm;
    }
    Person(String nm, int a) {
        this(nm);
        age = a;
    }
}

class PersonDemo {
    public static void main(String[] args) {
        Person p = new Person("张三", 23);
    }
}



 

图列说明：

1、先执行main方法，main方法压栈，执行其中的new Person(“张三”,23);
2、堆内存中开辟空间，并为其分配内存地址0x33，，紧接着成员变量默认初始化（name=null age = 0）；
3、拥有两个参数的构造方法（Person（String nm , int a））压栈，在这个构造方法中有一个隐式的this，因为构造方法是给对象初始化的，那个对象调用到这个构造方法，this就指向堆中的那个对象。
4、由于Person（String nm , int a）构造方法中使用了this(nm);构造方法Person(String nm)就会压栈，并将“张三”传递给nm。在Person（String nm , int a）构造方法中同样也有隐式的this，this的值同样也为0x33，这时会执行其中name = nm，即把“张三”赋值给成员的name。当赋值结束后Person（String nm , int a）构造方法弹栈。
5、程序继续执行构造方法（Person（String nm , int a）中的age = a；这时会将23赋值给成员属性age。赋值结束构造方法（Person（String nm , int a）弹栈。
6、当构造方法（Person（String nm , int a）弹栈结束后，Person对象在内存中创建完成，并将0x33赋值给main方法中的p引用变量。
this到底代表什么呢？this代表的是对象，具体代表哪个对象呢？哪个对象调用了this所在的方法，this就代表哪个对象。
调用其他构造方法的语句必须定义在构造方法的第一行，原因是初始化动作要最先执行。
成员变量和局部变量同名问题
通过上面学习，基本明确了对象初始化过程中的细节，也知道了构造方法之间的调用是通过this关键字完成的。但this也有另外一个用途，当在方法中出现了局部变量和成员变量同名的时候，那么在方法中怎么区别局部变量成员变量呢？可以在成员变量名前面加上this.来区别成员变量和局部变量。


class Person {
    private int age;
    private String name;

    // 给姓名和年龄初始化的构造方法
    Person(String name, int age) {
    // 当需要访问成员变量是，只需要在成员变量前面加上this.即可
        this.name = name;
        this.age = age;
    }
    public void speak() {
        System.out.println("name=" + this.name + ",age=" + this.age);
    }
}

class PersonDemo {
    public static void main(String[] args) {
        Person p = new Person("张三", 23);
        p.speak();
    }
}

this的应用
学习完了构造方法、this的用法之后，现在做个小小的练习。需求：在Person类中定义功能，判断两个人是否是同龄人


class Person {
    private int age;
    private String name;

    // 给姓名和年龄初始化的构造方法
    Person(String name, int age) {
   // 当需要访问成员变量是，只需要在成员变量前面加上this.即可
        this.name = name;
        this.age = age;
    }

    public void speak() {
        System.out.println("name=" + this.name + ",age=" + this.age);
    }

    // 判断是否为同龄人
    public boolean equalsAge(Person p) {
    // 使用当前调用该equalsAge方法对象的age和传递进来p的age进行比较
    // 由于无法确定具体是哪一个对象调用equalsAge方法，这里就可以使用this来代替
    /*
    * if(this.age == p.age) { return true; } return false;
    */
        return this.age = p.age;
    }
}

super关键字
子父类中构造方法的调用
在创建子类对象时，父类的构造方法会先执行，因为子类中所有构造方法的第一行有默认的隐式super();语句。
格式：


//调用本类中的构造方法
this(实参列表);
//调用父类中的空参数构造方法
super();
//调用父类中的有参数构造方法
super(实参列表);

为什么子类对象创建都要访问父类中的构造方法？因为子类继承了父类的内容，所以创建对象时，必须要先看父类是如何对其内容进行初始化的，看如下程序：


public class Test {
    public static void main(String[] args) {
        new Zi();
    }

}
class Fu{
    int num ;
    Fu(){
        System.out.println("Fu构造方法"+num);
        num = 4;
    }
}
class Zi extends Fu{
    Zi(){
    //super(); 调用父类空参数构造方法
        System.out.println("Zi构造方法"+num);
    }
}
//　　执行结果：
//　　Fu构造方法0
//　　Zi构造方法4

通过结果发现，子类构造方法执行时中，调用了父类构造方法，这说明，子类构造方法中有一句super()。那么，子类中的构造方法为什么会有一句隐式的super()呢？

原因：子类会继承父类中的内容，所以子类在初始化时，必须先到父类中去执行父类的初始化动作。这样，才可以使用父类中的内容。
当父类中没有空参数构造方法时，子类的构造方法必须有显示的super语句，指定要访问的父类有参数构造方法。

子类对象创建过程的细节
如果子类的构造方法第一行写了this调用了本类其他构造方法，那么super调用父类的语句还有吗？这时是没有的，因为this()或者super(),只能定义在构造方法的第一行，因为初始化动作要先执行。
父类构造方法中是否有隐式的super呢？也是有的。记住：只要是构造方法默认第一行都是super();
父类的父类是谁呢？super调用的到底是谁的构造方法呢？Java体系在设计，定义了一个所有对象的父类Object

类中的构造方法默认第一行都有隐式的super()语句，用来访问父类中的空参数构造方法。所以父类的构造方法既可以给自己的对象初始化，也可以给自己的子类对象初始化。如果默认的隐式super()语句在父类中没有对应的构造方法，那么必须在构造方法中通过this或者super的形式明确要调用的构造方法。
super应用
练习：描述学生和工人这两个类，将他们的共性name和age抽取出来存放在父类中，并提供相应的get和set方法，同时需要在创建学生和工人对象就必须明确姓名和年龄


//定义Person类，将Student和Worker共性抽取出来
class Person {
    private String name;
    private int age;
    public Person(String name, int age) {
// super();
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
}
class Student extends Person {
// Student类的构造方法
    Student(String name, int age) {
// 使用super关键字调用父类构造方法，进行相应的初始化动作
        super(name, age);
    }
    public void study() {// Studnet中特有的方法
        System.out.println(this.getName() + "同学在学习");
    }
}
class Worker extends Person {
    Worker(String name, int age) {
// 使用super关键字调用父类构造方法，进行相应的初始化动作
        super(name, age);
    }
    public void work() {// Worker 中特有的方法
        System.out.println(this.getName() + "工人在工作");
    }
}
public class Test {
    public static void main(String[] args) {
        Student stu = new Student("小明",23);
        stu.study();

        Worker w = new Worker("小李",45);
        w.work();
    }
}

知识点总结
this关键字

this关键字，本类对象的引用
this是在方法中使用的，哪个对象调用了该方法，那么，this就代表调用该方法的对象引用
this什么时候存在的？当创建对象的时候，this存在的
this的作用：用来区别同名的成员变量与局部变量（this.成员变量）
public void setName(String name) {
    this.name = name;
}
构造方法： 用来给类的成员进行初始化操作

格式：

修饰符 类名 (参数列表) {
    ...
}
构造方法的特点：

方法名与类名相同
没有返回值，也没有返回值类型，连void也没有
只有在创建对象的时候才可以被调用
super关键字

super指的是父类的存储空间(理解为父类的引用)
调用父类的成员变量：super.成员变量;
调用父类的构造方法:super(参数);
调用父类的成员方法:super.成员方法();
继承中的构造方法注意事项：

如果我们手动给出了构造方法，编译器不会在给我们提供默认的空参数构造方法
如果我们没写任何的构造方法，编译器提供给我们一个空参数构造方法
在构造方法中，默认的第一条语句为 super();它是用来访问父类中的空参数构造方法，进行父类成员的初始化操作
当父类中没有空参数构造方法的时候， 可以通过 super(参数) 访问父类有参数的构造方法； 也可以通过 this(参数) 访问本类中其他构造方法，前提是本类中的其他构造方法已经能够正常访问父类构造方法；
super(参数) 与 this(参数) 不能同时在构造方法中存在。
Java基础学习笔记十 Java基础语法之final、static、匿名对象、内部类
final关键字
继承的出现提高了代码的复用性，并方便开发。但随之也有问题，有些类在描述完之后，不想被继承，或者有些类中的部分方法功能是固定的，不想让子类重写。可是当子类继承了这些特殊类之后，就可以对其中的方法进行重写，那怎么解决呢？要解决上述的这些问题，需要使用到一个关键字final，final的意思为最终，不可变。final是个修饰符，它可以用来修饰类，类的成员，以及局部变量。

final的特点
final修饰类不可以被继承，但是可以继承其他类。

class Yy {}
final class Fu extends Yy{} //可以继承Yy类
class Zi extends Fu{} //不能继承Fu类
final修饰的方法不可以被覆盖,但父类中没有被final修饰方法，子类覆盖后可以加final。

class Fu {
    // final修饰的方法，不可以被覆盖，但可以继承使用
    public final void method1(){}
    public void method2(){}
}
class Zi extends Fu {
    //重写method2方法
    public final void method2(){}
}

final修饰的变量称为常量，这些变量只能赋值一次。
 final int i = 20;
 i = 30; //赋值报错，final修饰的变量只能赋值一次
引用类型的变量值为对象地址值，地址值不能更改，但是地址内的对象属性值可以修改。
final Person p = new Person();
Person p2 = new Person();
p = p2; //final修饰的变量p，所记录的地址值不能改变
p.name = "小明";//可以更改p对象中name属性值
//p不能为别的对象，而p对象中的name或age属性值可更改。
修饰成员变量，需要在创建对象前赋值，否则报错。(当没有显式赋值时，多个构造方法的均需要为其赋值。)

class Demo {
    //直接赋值
    final int m = 100;

    //final修饰的成员变量，需要在创建对象前赋值，否则报错。
    final int n;
    public Demo(){
    //可以在创建对象时所调用的构造方法中，为变量n赋值
        n = 2016;
    }
}

static关键字
当在定义类的时候，类中都会有相应的属性和方法。而属性和方法都是通过创建本类对象调用的。当在调用对象的某个方法时，这个方法没有访问到对象的特有数据时，方法创建这个对象有些多余。可是不创建对象，方法又调用不了，这时就会想，那么我们能不能不创建对象，就可以调用方法呢？可以的，我们可以通过static关键字来实现。static它是静态修饰符，一般用来修饰类中的成员。

static特点
被static修饰的成员变量属于类，不属于这个类的某个对象。（也就是说，多个对象在访问或修改static修饰的成员变量时，其中一个对象将static成员变量值进行了修改，其他对象中的static成员变量值跟着改变，即多个对象共享同一个static成员变量）


class Demo {
    public static int num = 100;
}

class Test {
    public static void main(String[] args) {
        Demo d1 = new Demo();
        Demo d2 = new Demo();
        d1.num = 200;
        System.out.println(d1.num); //结果为200
        System.out.println(d2.num); //结果为200
    }
}

被static修饰的成员可以并且建议通过类名直接访问。访问静态成员的格式：

类名.静态成员变量名
类名.静态成员方法名(参数)
对象名.静态成员变量名 ------不建议使用该方式，会出现警告
对象名.静态成员方法名(参数) ------不建议使用该方式，会出现警告

class Demo {
    //静态成员变量
    public static int num = 100;
    //静态方法
    public static void method(){
        System.out.println("静态方法");
    }
}
class Test {
    public static void main(String[] args) {
        System.out.println(Demo.num);
        Demo.method();
    }
}

static注意事项
静态内容是优先于对象存在，只能访问静态，不能使用this/super。静态修饰的内容存于静态区。


class Demo {
    //成员变量
    public int num = 100;
    //静态方法
    public static void method(){
//this.num; 不能使用this/super。
        System.out.println(this.num);
    }
}

同一个类中，静态成员只能访问静态成员。


class Demo {
    //成员变量
    public int num = 100;
    //静态成员变量
    public static int count = 200;
    //静态方法
    public static void method(){
//System.out.println(num); 静态方法中，只能访问静态成员变量或静态成员方法
        System.out.println(count);
    }
}

main方法为静态方法仅仅为程序执行入口，它不属于任何一个对象，可以定义在任意类中。

定义静态常量
开发中，我们想在类中定义一个静态常量，通常使用public static final修饰的变量来完成定义。此时变量名用全部大写，多个单词使用下划线连接。
定义格式： public static final 数据类型 变量名 = 值; 


class Company {
    public static final String COMPANY_NAME = "百度";
    public static void method(){
        System.out.println("一个静态方法");
    }
}

当我们想使用类的静态成员时，不需要创建对象，直接使用类名来访问即可。

System.out.println(Company.COMPANY_NAME); //打印百度
Company.method(); // 调用一个静态方法
注意：

接口中的每个成员变量都默认使用public static final修饰。
所有接口中的成员变量已是静态常量，由于接口没有构造方法，所以必须显示赋值。可以直接用接口名访问。
interface Inter {
    public static final int COUNT = 100;
}
//访问接口中的静态变量
Inter.COUNT
匿名对象
匿名对象是指创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。


public class Person{
    public void eat(){
        System.out.println();
    }
}

//创建一个普通对象
Person p = new Person();
//创建一个匿名对象
new Person();

匿名对象的特点：

创建匿名对象直接使用，没有变量名。

new Person().eat() //eat方法被一个没有名字的Person对象调用了。
匿名对象在没有指定其引用变量时，只能使用一次。

new Person().eat(); 创建一个匿名对象，调用eat方法
new Person().eat(); 想再次调用eat方法，重新创建了一个匿名对象
匿名对象可以作为方法接收的参数、方法返回值使用


class Demo {
    public static Person getPerson(){
//普通方式
//Person p = new Person(); 
//return p;

//匿名对象作为方法返回值
        return new Person();
    }
    public static void method(Person p){}
}
class Test {
    public static void main(String[] args) {
//调用getPerson方法，得到一个Person对象
    Person person = Demo.getPerson();
//调用method方法
    Demo.method(person);
//匿名对象作为方法接收的参数
    Demo.method(new Person());
    }
}

内部类
将类写在其他类的内部，可以写在其他类的成员位置和局部位置，这时写在其他类内部的类就称为内部类。其他类也称为外部类。
什么时候使用内部类?在描述事物时，若一个事物内部还包含其他可能包含的事物，比如在描述汽车时，汽车中还包含这发动机，这时发动机就可以使用内部类来描述。

class 汽车 { //外部类
    class 发动机 { //内部类
    }
}
内部类的分类
内部类分为成员内部类与局部内部类。
定义内部类时，就是一个正常定义类的过程，同样包含各种修饰符、继承与实现关系等。在内部类中可以直接访问外部类的所有成员。
成员内部类，定义在外部类中的成员位置。与类中的成员变量相似，可通过外部类对象进行访问
定义格式：

class 外部类 {
    修饰符 class 内部类 {
    //其他代码
    }
}
访问方式： 外部类名.内部类名 变量名 = new 外部类名().new 内部类名();


class Body {//外部类，身体
    private boolean life = true; //生命状态

    public class Heart { //内部类，心脏
        public void jump() {
            System.out.println("心脏噗通噗通的跳")
            System.out.println("生命状态" + life); //访问外部类成员变量
        }
    }
}
//访问内部类
    public static void main(String[] args) {
//创建内部类对象
        Body.Heart bh = new Body().new Heart();
//调用内部类中的方法
        bh.jump();
    }

局部内部类，定义在外部类方法中的局部位置。与访问方法中的局部变量相似，可通过调用方法进行访问

定义格式：


class 外部类 {
    修饰符 返回值类型 方法名(参数) {
        class 内部类 {
        //其他代码
        }
    }
} 

访问方式：在外部类方法中，创建内部类对象，进行访问

局部内部类代码演示


//定义类
class Party {//外部类，聚会
    public void puffBall() {// 吹气球方法
        class Ball {// 内部类，气球
            public void puff() {
                System.out.println("气球膨胀了");
            }
        }
    //创建内部类对象，调用puff方法
        new Ball().puff();
    }
}

    //访问内部类
    public static void main(String[] args) {
    //创建外部类对象
        Party p = new Party();
    //调用外部类中的puffBall方法
        p.puffBall();
    }

内部类的实际使用——匿名内部类
内部类是为了应对更为复杂的类间关系。查看源代码中会涉及到，而在日常业务中很难遇到，这里不做赘述。最常用到的内部类就是匿名内部类，它是局部内部类的一种。
定义的匿名内部类有两个含义：

临时定义某一指定类型的子类
定义后即刻创建刚刚定义的这个子类的对象
定义匿名内部类的作用与格式
作用：匿名内部类是创建某个类型子类对象的快捷方式。
格式：

new 父类或接口(){
    //进行方法重写
};
代码演示：


//已经存在的父类：
public abstract class Person{
    public abstract void eat();
}
    //定义并创建该父类的子类对象，并用多态的方式赋值给父类引用变量
    Person p = new Person(){
        public void eat() {
            System.out.println(“我吃了”);
        }
    };
//调用eat方法
p.eat();

使用匿名对象的方式，将定义子类与创建子类对象两个步骤由一个格式一次完成。虽然是两个步骤，但是两个步骤是连在一起完成的。

匿名内部类如果不定义变量引用，则也是匿名对象。代码如下：

new Person(){
public void eat() {
        System.out.println(“我吃了”);
    }
}.eat();
包的声明与访问
java的包，其实就是我们电脑系统中的文件夹，包里存放的是类文件。当类文件很多的时候，通常我们会采用多个包进行存放管理他们，这种方式称为分包管理。
在项目中，我们将相同功能的类放到一个包中，方便管理。并且日常项目的分工也是以包作为边界。
类中声明的包必须与实际class文件所在的文件夹情况相一致，即类声明在a包下，则生成的.class文件必须在a文件夹下，否则，程序运行时会找不到类。

包的声明格式
通常使用公司网址反写，可以有多层包，包名采用全部小写字母，多层包之间用”.”连接。
类中包的声明格式：  package 包名.包名.包名…; 
如：黑马程序员网址itheima.com，那么网址反写就为com.itheima
注意：声明包的语句，必须写在程序有效代码的第一行（注释不算）
代码演示：


package cn.itcast; //包的声明，必须在有效代码的第一行

import java.util.Scanner;
import java.util.Random;

public class Demo {}

包的访问
在访问类时，为了能够找到该类，必须使用含有包名的类全名（包名.类名）。 包名.包名….类名 ，如： java.util.Scanner
带有包的类，创建对象格式： 包名.类名 变量名 = new包名.类名(); 比如cn.itcast.Demo d = new cn.itcast.Demo();
前提：包的访问与访问权限密切相关，这里以一般情况来说，即类用public修饰的情况。

类的简化访问
当我们要使用一个类时，这个类与当前程序在同一个包中（即同一个文件夹中），或者这个类是java.lang包中的类时通常可以省略掉包名，直接使用该类。
当我们要使用的类，与当前程序不在同一个包中（即不同文件夹中），要访问的类必须用public修饰才可访问。

import导包
我们每次使用类时，都需要写很长的包名。很麻烦，我们可以通过import导包的方式来简化。通过导包的方式使用该类，可以避免使用全类名编写（即，包类.类名）。
导包的格式： import 包名.类名; 

当程序导入指定的包后，使用类时，就可以简化了。演示如下：


//导入包前的方式
//创建对象
java.util.Random r1 = new java.util.Random();
        java.util.Random r2 = new java.util.Random();
        java.util.Scanner sc1 = new java.util.Scanner(System.in);
        java.util.Scanner sc2 = new java.util.Scanner(System.in);

//导入包后的方式
        import java.util.Random;
        import java.util.Scanner;
//创建对象
        Random r1 = new Random();
        Random r2 = new Random();
        Scanner sc1 = new Scanner(System.in);
        Scanner sc2 = new Scanner(System.in);

import导包代码书写的位置：在声明包package后，定义所有类class前，使用导包import包名.包名.类名;

访问修饰符
在Java中提供了四种访问权限，使用不同的访问权限时，被修饰的内容会有不同的访问权限，以下表来说明不同权限的访问能力：

 	
public

protected

default

private

同一类中

√

√

√

√

同一包中(子类与无关类)

√

√

√

 

不同包的子类

√

√

 

 

不同包中的无关类

√

 

 

 
归纳总结：

要想仅能在本类中访问使用private修饰；
要想本包中的类都可以访问不加修饰符即可；
要想本包中的类与其他包中的子类可以访问使用protected修饰
要想所有包中的所有类都可以访问使用public修饰。
注意：如果类用public修饰，则类名必须与文件名相同。一个文件中只能有一个public修饰的类。
代码块
局部代码块：局部代码块是定义在方法或语句中。
特点：

以”{}”划定的代码区域，此时只需要关注作用域的不同即可
方法和类都是以代码块的方式划定边界的

class Demo{
    public static void main(String[] args) {
        {
            int x = 1;
            System.out.println("普通代码块" + x);
        }
        int x = 99;
        System.out.println("代码块之外" + x);
    }
}

构造代码块:构造代码块是定义在类中成员位置的代码块

特点：

优先于构造方法执行，构造代码块用于执行所有对象均需要的初始化动作
每创建一个对象均会执行一次构造代码块。

public class Person {
    private String name;
    private int age;

    //构造代码块
    {
        System.out.println("构造代码块执行了");
    }
    Person(){
        System.out.println("Person无参数的构造函数执行");
    }
    Person(int age){
        this.age = age;
        System.out.println("Person（age）参数的构造函数执行");
    }
}
class PersonDemo{
    public static void main(String[] args) {
        Person p = new Person();
        Person p1 = new Person(23);
    }
}

静态代码块：静态代码块是定义在成员位置，使用static修饰的代码块。

特点：
它优先于主方法执行、优先于构造代码块执行，当以任意形式第一次使用到该类时执行。
该类不管创建多少对象，静态代码块只执行一次。
可用于给静态变量赋值，用来给类进行初始化。


public class Person {
    private String name;
    private int age;
    //静态代码块
    static{
        System.out.println("静态代码块执行了");
    }
}

知识点总结
1、final：关键字，最终的意思

final修饰的类：最终的类，不能被继承
final修饰的变量： 相当于是一个常量, 在编译生产.class文件后，该变量变为常量值
final修饰的方法： 最终的方法，子类不能重写，可以继承过来使用
2、static : 关键字， 静态的意思

可以用来修饰类中的成员(成员变量，成员方法)
也可以用来修饰成员内部类
特点：

被静态所修饰的成员，会被所有的对象所共享
被静态所修饰的成员，可以通过类名直接调用，方便
Person.country = "中国";
Person.method();
注意事项：

静态的成员，随着类的加载而加载，优先于对象存在
在静态方法中，没有this关键字
静态方法中，只能调用静态的成员(静态成员变量，静态成员方法
3、匿名对象：一个没有名字的对象
特点：

创建匿名对象直接使用，没有变量名
匿名对象在没有指定其引用变量时，只能使用一次
匿名对象可以作为方法接收的参数、方法返回值使用
4、内部类：在一个类中，定义了一个新类，这个新的类就是内部类

class A {//外部类
    class B{// 内部类
    }
}
特点： 内部类可以直接访问外部类的成员，包含私有的成员

5、包的声明与访问
类中包的声明格式： package 包名.包名.包名…;
带有包的类，创建对象格式：包名.类名 变量名 = new包名.类名();
6、导包的格式：import 包名.类名;

7、权限修饰符

public : 公共的
protected: 受保护的
private : 私有的
public protected 默认的 private
8、代码块：

局部代码块：定义在方法中的，用来限制变量的作用范围
构造代码块：定义在类中方法外，用来给对象中的成员初始化赋值
静态代码块：定义在类中方法外，用来给类的静态成员初始化赋值
Java基础学习笔记十二 类、抽象类、接口作为方法参数和返回值以及常用API
不同修饰符使用细节
常用来修饰类、方法、变量的修饰符
public 权限修饰符，公共访问, 类,方法,成员变量
protected 权限修饰符，受保护访问, 方法,成员变量
默认什么也不写 也是一种权限修饰符，默认访问, 类,方法,成员变量
private 权限修饰符，私有访问, 方法,成员变量
static 静态修饰符 方法,成员变量
final 最终修饰符 类,方法,成员变量,局部变量
abstract 抽象修饰符 类 ,方法
我们编写程序时，权限修饰符一般放于所有修饰符之前，不同的权限修饰符不能同时使用；

同时，abstract与private不能同时使用；
同时，abstract与static不能同时使用；
同时，abstract与final不能同时使用。
修饰类能够使用的修饰符
修饰类只能使用public、默认的、final、abstract关键字，使用最多的是 public关键字

public class Demo {} //最常用的方式
class Demo2{}
public final class Demo3{}
public abstract class Demo4{}
修饰成员变量能够使用的修饰符
public : 公共的
protected : 受保护的
: 默认的
private ：私有的
final : 最终的
static : 静态的
使用最多的是 private


public int count = 100;
protected int count2 = 100;
int count3 = 100;
private int count4 = 100; //最常用的方式
public final int count5 = 100;
public static int count6 = 100;

修饰构造方法能够使用的修饰符
public : 公共的
protected : 受保护的
: 默认的
private ：私有的
使用最多的是 public

public Demo(){} //最常用的方式
protected Demo(){}
Demo(){}
private Demo(){}
修饰成员方法能够使用的修饰符
public : 公共的
protected : 受保护的
: 默认的
private ：私有的
final : 最终的
static : 静态的
abstract : 抽象的
使用最多的是 public


public void method1(){}//最常用的方式
protected void method2(){}
void method3(){}
private void method4(){}
public final void method5(){}
public static void method6(){}//最常用的方式
public abstract void method7();//最常用的方式

类作为方法参数与返回值
类作为方法参数
在编写程序中，会经常碰到调用的方法要接收的是一个类类型的情况，那么这时，要向方法中传入该类的对象。如下代码演示：


class Person{
    public void show(){
        System.out.println("show方法执行了");
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
//创建Person对象
        Person p = new Person();
//调用method方法
        method(p);
    }
    //定义一个方法method，用来接收一个Person对象，在方法中调用Person对象的show方法

    public static void method(Person p){
        p.show();
    }
}

类作为方法返回值
写程序调用方法时，我们以后会经常碰到返回一个类类型的返回值，那么这时，该方法要返回一个该类的对象。如下代码演示：


class Person{
    public void show(){
        System.out.println("show方法执行了");
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
//调用method方法，获取返回的Person对象
        Person p = method();
//调用p对象中的show方法
        p.show();
    }

    //定义一个方法method，用来获取一个Person对象，在方法中完成Person对象的创建
    public static Person method(){
        Person p = new Person();
        return p;
    }
}

抽象类作为方法参数与返回值
抽象类作为方法参数
开发中，抽象类作为方法参数的情况也很多见。当遇到方法参数为抽象类类型时，要传入一个实现抽象类所有抽象方法的子类对象。如下代码演示：


//抽象类
abstract class Person{
    public abstract void show();
}
class Student extends Person{
    @Override
    public void show() {
        System.out.println("重写了show方法");
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
//通过多态的方式，创建一个Person类型的变量，而这个对象实际是Student
        Person p = new Student();
//调用method方法
        method(p);
    }

    //定义一个方法method，用来接收一个Person类型对象，在方法中调用Person对象的show方法
    public static void method(Person p){//抽象类作为参数
//通过p变量调用show方法,这时实际调用的是Student对象中的show方法
        p.show();
    }
}

抽象类作为方法返回值
抽象类作为方法返回值的情况，也是有的，这时需要返回一个实现抽象类所有抽象方法的子类对象。如下代码演示：


//抽象类
abstract class Person{
    public abstract void show();
}
class Student extends Person{
    @Override
    public void show() {
        System.out.println("重写了show方法");
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
//调用method方法，获取返回的Person对象
        Person p = method();
//通过p变量调用show方法,这时实际调用的是Student对象中的show方法
        p.show();
    }

    //定义一个方法method，用来获取一个Person对象，在方法中完成Person对象的创建
    public static Person method(){
        Person p = new Student();
        return p;
    }
}

接口作为方法参数与返回值
接口作为方法参数
接口作为方法参数的情况是很常见的，经常会碰到。当遇到方法参数为接口类型时，那么该方法要传入一个接口实现类对象。如下代码演示。


//接口
interface Smoke{
    public abstract void smoking();
}
class Student implements Smoke{
    @Override
    public void smoking() {
        System.out.println("课下吸口烟，赛过活神仙");
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
    //通过多态的方式，创建一个Smoke类型的变量，而这个对象实际是Student
        Smoke s = new Student();
        //调用method方法
        method(s);
    }

    //定义一个方法method，用来接收一个Smoke类型对象，在方法中调用Smoke对象的show方法
    public static void method(Smoke sm){//接口作为参数
    //通过sm变量调用smoking方法，这时实际调用的是Student对象中的smoking方法
        sm.smoking();
    }
}

接口作为方法返回值
接口作为方法返回值的情况，在后面的学习中会碰到。当遇到方法返回值是接口类型时，那么该方法需要返回一个接口实现类对象。如下代码演示。


//接口
interface Smoke{
    public abstract void smoking();
}
class Student implements Smoke{
    @Override
    public void smoking() {
        System.out.println("课下吸口烟，赛过活神仙");
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
//调用method方法，获取返回的会吸烟的对象
        Smoke s = method();
//通过s变量调用smoking方法,这时实际调用的是Student对象中的smoking方法
        s.smoking();
    }

 //定义一个方法method，用来获取一个具备吸烟功能的对象，并在方法中完成吸烟者的创建
    public static Smoke method(){
        Smoke sm = new Student();
        return sm;
    }
}

归纳总结：

类作为方法参数时，说明要向方法中传入该类的对象
类作为方法返回值时，说明该方法要返回一个该类的对象。
抽象类作为方法参数时，说明要传入一个实现抽象类所有抽象方法的子类对象。
抽象类作为方法返回值时，说明需要返回一个实现抽象类所有抽象方法的子类对象。
接口作为方法参数时，说明该方法要传入一个接口实现类对象。
接口作为方法返回值时，说明该方法需要返回一个接口实现类对象。
常用API
Java 的API（API: Application(应用) Programming(程序) Interface(接口)）就是JDK中提供给我们使用的类，这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。

在JDK安装目录下有个src.zip文件，这个文件解压缩后里面的内容是所有Java类的源文件。可以在其中查看相对应的类的源码。
我们在每次查看类中的方法时，都打开源代码进行查看，这种方式过于麻烦。其实，我们可以通过查帮助文档的方式，来了解Java提供的API如何使用。如下图操作：查找Object类



 

通过帮助文档中类与方法的介绍，我们就能够使用这个类了。

Object类
Object类是Java语言中的根类，即所有类的父类。所有类在创建对象的时候，最终找的父类就是Object。

equals方法
equals方法，用于比较两个对象是否相同，它其实就是使用两个对象的内存地址在比较。Object类中的equals方法内部使用的就是==比较运算符。
在开发中要比较两个对象是否相同，经常会根据对象中的属性值进行比较，也就是在开发经常需要子类重写equals方法根据对象的属性值进行比较。如下代码演示：


/*
描述人这个类，并定义功能根据年龄判断是否是同龄人
由于要根据指定类的属性进行比较，这时只要覆盖Object中的equals方法
在方法体中根据类的属性值进行比较
*/
class Person extends Object{
    int age ;
    //复写父类的equals方法，实现自己的比较方式
    public boolean equals(Object obj) {
//判断当前调用equals方法的对象和传递进来的对象是否是同一个
        if(this == obj){
            return true;
        }
//判断传递进来的对象是否是Person类型
        if(!(obj instanceof Person)){
            return false;
        }
//将obj向下转型为Perosn引用，访问其属性
        Person p = (Person)obj;
        return this.age == p.age;
    }
}

注意：在复写Object中的equals方法时，一定要注意public boolean equals(Object obj)的参数是Object类型，在调用对象的属性时，一定要进行类型转换，在转换之前必须进行类型判断。

toString方法
toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。
由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。


class Person extends Object{
    int age ;
    //根据Person类的属性重写toString方法
    public String toString() {
        return "Person [age=" + age + "]";
    }
}

String类
查阅API中的String类的描述，发现String 类代表字符串。Java 程序中的所有字符串字面值（如 "abc" ）都作为此类的实例实现。

//演示字符串
String str = "AAA";
str = "BBB";
字符串是常量；它们的值在创建之后不能更改。也就是说一旦这个字符串确定了，那么就会在内存区域中就生成了这个字符串。字符串本身不能改变，但str变量中记录的地址值是可以改变的。

字符串有大量的重载的构造方法。通过String类的构造方法可以完成字符串对象的创建，那么，通过使用双引号的方式创建对象与new的方式创建对象，有什么不同呢？

String s3 = "abc";
String s4 = new String("abc");
System.out.println(s3==s4);//false
System.out.println(s3.equals(s4));//true,
////因为String重写了equals方法，建立了字符串自己的判断相同的依据（通过字符串对象中的字符来判断）
 s3和s4的创建方式有什么不同呢？

s3创建，在内存中只有一个对象。这个对象在字符串常量池中
s4创建，在内存中有两个对象。一个new的对象在堆中，一个字符串本身对象，在字符串常量池中

String类构造方法
构造方法是用来完成String对象的创建，下图中给出了一部分构造方法需要在API中找到，并能够使用下列构造方法创建对象。




String s1 = new String(); //创建String对象，字符串中没有内容

byte[] bys = new byte[]{97,98,99,100};
String s2 = new String(bys); // 创建String对象，把数组元素作为字符串的内容
String s3 = new String(bys, 1, 3); //创建String对象，把一部分数组元素作为字符串的内容，参数offset为数组元素的起始索引位置，参数length为要几个元素

char[] chs = new char[]{’a’,’b’,’c’,’d’,’e’};
String s4 = new String(chs); //创建String对象，把数组元素作为字符串的内容
String s5 = new String(chs, 0, 3);//创建String对象，把一部分数组元素作为字符串的内容，参数offset为数组元素的起始索引位置，参数count为要几个元素

String s6 = new String(“abc”); //创建String对象，字符串内容为abc

String类的方法查找
String类中有很多的常用的方法，我们在学习一个类的时候，不要盲目的把所有的方法尝试去使用一遍，这时我们应该根据这个对象的特点分析这个对象应该具备那些功能，这样大家应用起来更方便。
字符串是一个对象，那么它的方法必然是围绕操作这个对象的数据而定义的。我们想想字符串中有哪些功能呢？
1、字符串中有多少个字符?

String str = "abcde";
int len = str.length();
System.out.println("len="+len);
2、获取部分字符串


String str = "abcde";
String s1 = str.substring(1); //返回一个新字符串，内容为指定位置开始到字符串末尾的所有字符
String s2 = str.substring(2, 4);//返回一个新字符串，内容为指定位置开始到指定位置结束所有字符
System.out.println("str="+str);
System.out.println("s1="+s1);
System.out.println("s2="+s2);

3、字符串是否以指定字符串开头。结尾同理

String str = "StringDemo.java";
boolean b1 = str.startsWith("Demo");//判断是否以给定字符串开头
boolean b2 = str.startsWith("String");
boolean b3 = str.endsWith("java");//判断是否以给定字符串结尾
4、字符串中是否包含另一个字符串

String str = "abcde";
int index = str.indexOf(“bcd”); //判断是否包含指定字符串，包含则返回第一次出现该字符串的索引，不包含则返回-1
boolean b2 = str.contains("bcd");//判断是否包含指定字符串，包含返回true，不包含返回false
5、将字符串转成一个字符数组。或者字节数组

String str = "abcde";
char[] chs = str.toCharArray();
byte[] bytes = str.getBytes();
6、判断两个字符串中的内容是否相同

String str = "abcde";
String str2 = "abcde";
String str3 = "hello";
boolean b1 = str.equals(str2);
boolean b2 = str.equals(str3);
7、获取该字符串对象中的内容

String str = new String("hello");
System.out.println( str.toString() );
System.out.pintln( str );
直接打印引用类型变量时，默认调用该类型进行重写后的toString方法

下面的需求所对应的方法，自己动手在API中查找，并进行方法使用。

判断该字符串的内容是否为空的字符串
获取给定的字符，在该字符串中第一次出现的位置
获取该字符串中指定位置上的字符
把该字符串转换成 小写字符串
把该字符串转换成 大写字符串
在该字符串中，将给定的旧字符，用新字符替换
在该字符串中， 将给定的旧字符串，用新字符串替换
去除字符串两端空格，中间的不会去除，返回一个新字符串
StringBuffer类
在学习String类时，API中说字符串缓冲区支持可变的字符串，什么是字符串缓冲区呢？接下来我们来研究下字符串缓冲区。
查阅StringBuffer的API，StringBuffer又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。
原来StringBuffer是个字符串的缓冲区，即就是它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。

StringBuffer的方法使用
代码演示：
创建一个字符串缓冲区对象。用于存储数据。


StringBuffer sb = new StringBuffer();
sb.append("haha"); //添加字符串
sb.insert(2, "it");//在指定位置插入
sb.delete(1, 4);//删除
sb.replace(1, 4, "cast");//替换指定范围内的内容
String str = sb.toString();

注意：append、delete、insert、replace、reverse方法调用后，返回值都是当前对象自己，所以说，StringBuffer它可以改变字符序列的长度和内容。

StringBuffer类方法查找练习
下面的需求所对应的方法，自己动手在API中查找，并进行方法使用。

从指定位置开始，到末尾结束，截取该字符串缓冲区，返回新字符串
在原有字符串缓冲区内容基础上，删除指定位置上的字符
对象的方法链式调用
在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。这种时候，我们就可以把代码现在一起，如append方法一样，代码如下：

//创建一个字符串缓冲区对象。用于存储数据。
StringBuffer sb = new StringBuffer();
//添加数据。不断的添加数据后，要对缓冲区的最后的数据进行操作，必须转成字符串才可以。
String str = sb.append(true).append("hehe").toString();
无论多少数据，数据是什么类型都不重要，只要最终变成字符串就可以使用StringBuffer这个容器。

StringBuilder类
查阅API发现还有一个StringBuilder类，它也是字符串缓冲区，StringBuilder与它和StringBuffer的有什么不同呢？
我们阅读StringBuilder的API说明发现，它也是一个可变的字符序列。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。

总结
1、Object: 它是所有类的超类，祖宗类。java中所有的类都直接或间接的继承这个类
方法：

public String toString() 返回当前对象中的内容, 对于Object类默认操作来说，返回的对象的类型+@+内存地址值
public boolean equals(Object obj) 比较两个对象内容是否相同，对于Object类默认操作来说,比较的是地址值
2、String: 字符串类，字符串是常量；它们的值在创建之后不能更改
方法：

boolean equals(Object obj) 判断两个字符串中的内容是否相同
boolean equalsIgnoreCase(String str) 判断两个字符串中的内容是否相同, 忽略大小写
boolean contains(String str) 判断该字符串中 是否包含给定的字符串
boolean startsWith(String str) 判断该字符串 是否以给定的字符串开头
boolean endsWith(String str) 判断该字符串 是否以给定的字符串结尾
boolean isEmpty() 判断该字符串的内容是否为空的字符串 ""
int length() 获取该字符串的长度
char charAt(int index) 获取该字符串中指定位置上的字符
String substring(int start) 从指定位置开始，到末尾结束，截取该字符串，返回新字符串
String substring(int start,int end) 从指定位置开始，到指定位置结束，截取该字符串，返回新字符串
int indexOf(int ch ) 获取给定的字符，在该字符串中第一次出现的位置
int indexOf(String str) 获取给定的字符串，在该字符串中第一次出现的位置
int indexOf(int ch,int fromIndex) 从指定位置开始，获取给定的字符，在该字符
byte[] getBytes() 把该字符串 转换成 字节数组
char[] toCharArray() 把该字符串 转换成 字符数组
String replace(char old,char new) 在该字符串中，将给定的旧字符，用新字符替换
String replace(String old,String new) 在该字符串中， 将给定的旧字符串，用新字符串替换
String trim() 去除字符串两端空格，中间的不会去除，返回一个新字符串
String toLowerCase() 把该字符串转换成 小写字符串
String toUpperCase() 把该字符串转换成 大写字符串
int indexOf(String str,int fromIndex) 从指定位置开始，获取给定的字符串，在该字符串中第一次出现的位置
3、StringBuffer/StringBuilder:
方法：

public StringBuffer append(String str) 在原有字符串缓冲区内容基础上，在末尾追加新数据
public StringBuffer insert(int offset,String str) 在原有字符串缓冲区内容基础上，在指定位置插入新数据
public StringBuffer deleteCharAt(int index) 在原有字符串缓冲区内容基础上，删除指定位置上的字符
public StringBuffer delete(int start,int end) 在原有字符串缓冲区内容基础上，删除指定范围内的多个字符
public StringBuffer replace(int start,int end,String str)在原有字符串缓冲区内容基础上，将指定范围内的多个字符 用给定的字符串替换
public StringBuffer reverse() 将字符串缓冲区的内容 反转 "abc"----"cba"
public String substring(int start) 从指定位置开始，到末尾结束，截取该字符串缓冲区，返回新字符串
public String substring(int start,int end) 从指定位置开始，到指定位置结束，截取该字符串缓冲区，返回新字符串
Java基础学习笔记十三 常用API之正则表达式、Date、DateFormat、Calendar
正则表达式
正则表达式（英语：Regular Expression，在代码中常简写为regex）。正则表达式是一个字符串，使用单个字符串来描述、用来定义匹配规则，匹配一系列符合某个句法规则的字符串。在开发中，正则表达式通常被用来检索、替换那些符合某个规则的文本。

正则表达式的匹配规则
参照帮助文档，在Pattern类中有正则表达式的的规则定义，正则表达式中明确区分大小写字母。我们来学习语法规则。

正则表达式的语法规则：

字符：x
含义：代表的是字符x
例如：匹配规则为 "a"，那么需要匹配的字符串内容就是 ”a”
字符：\\
含义：代表的是反斜线字符'\'
例如：匹配规则为"\\" ，那么需要匹配的字符串内容就是 ”\”
字符：\t
含义：制表符
例如：匹配规则为"\t" ，那么对应的效果就是产生一个制表符的空间
字符：\n
含义：换行符
例如：匹配规则为"\n"，那么对应的效果就是换行,光标在原有位置的下一行
字符：\r
含义：回车符
例如：匹配规则为"\r" ，那么对应的效果就是回车后的效果,光标来到下一行行首
字符类：[abc]
含义：代表的是字符a、b 或 c
例如：匹配规则为"[abc]" ，那么需要匹配的内容就是字符a，或者字符b，或字符c的一个
字符类：[^abc]
含义：代表的是除了 a、b 或 c以外的任何字符
例如：匹配规则为"[^abc]"，那么需要匹配的内容就是不是字符a，或者不是字符b，或不是字符c的任意一个字符
字符类：[a-zA-Z]
含义：代表的是a 到 z 或 A 到 Z，两头的字母包括在内
例如：匹配规则为"[a-zA-Z]"，那么需要匹配的是一个大写或者小写字母
字符类：[0-9]
含义：代表的是 0到9数字，两头的数字包括在内
例如：匹配规则为"[0-9]"，那么需要匹配的是一个数字
字符类：[a-zA-Z_0-9]
含义：代表的字母或者数字或者下划线(即单词字符)
例如：匹配规则为" [a-zA-Z_0-9] "，那么需要匹配的是一个字母或者是一个数字或一个下滑线
预定义字符类：.
含义：代表的是任何字符
例如：匹配规则为" . "，那么需要匹配的是一个任意字符。如果，就想使用 . 的话，使用匹配规则"\\."来实现
预定义字符类：\d
含义：代表的是 0到9数字，两头的数字包括在内，相当于[0-9]
例如：匹配规则为"\d "，那么需要匹配的是一个数字
预定义字符类：\w
含义：代表的字母或者数字或者下划线(即单词字符)，相当于[a-zA-Z_0-9]
例如：匹配规则为"\w "，，那么需要匹配的是一个字母或者是一个数字或一个下滑线
边界匹配器：^
含义：代表的是行的开头
例如：匹配规则为^[abc][0-9]$ ，那么需要匹配的内容从[abc]这个位置开始, 相当于左双引号
边界匹配器：$
含义：代表的是行的结尾
例如：匹配规则为^[abc][0-9]$ ，那么需要匹配的内容以[0-9]这个结束, 相当于右双引号
边界匹配器：\b
含义：代表的是单词边界
例如：匹配规则为"\b[abc]\b" ，那么代表的是字母a或b或c的左右两边需要的是非单词字符([a-zA-Z_0-9])
数量词：X?
含义：代表的是X出现一次或一次也没有
例如：匹配规则为"a?"，那么需要匹配的内容是一个字符a，或者一个a都没有
数量词：X*
含义：代表的是X出现零次或多次
例如：匹配规则为"a*" ，那么需要匹配的内容是多个字符a，或者一个a都没有
数量词：X+
含义：代表的是X出现一次或多次
例如：匹配规则为"a+"，那么需要匹配的内容是多个字符a，或者一个a
数量词：X{n}
含义：代表的是X出现恰好 n 次
例如：匹配规则为"a{5}"，那么需要匹配的内容是5个字符a
数量词：X{n,}
含义：代表的是X出现至少 n 次
例如：匹配规则为"a{5, }"，那么需要匹配的内容是最少有5个字符a
数量词：X{n,m}
含义：代表的是X出现至少 n 次，但是不超过 m 次
例如：匹配规则为"a{5,8}"，那么需要匹配的内容是有5个字符a 到 8个字符a之间
正则表达式规则匹配练习
请写出满足如下匹配规则的字符串:

规则："[0-9]{6,12}"

该规则需要匹配的内容是：长度为6位到12位的数字。如：使用数据"123456789"进行匹配结果为true；使用数据"12345"进行匹配结果为false。

 

规则："1[34578][0-9]{9}"

该规则需要匹配的内容是：11位的手机号码，第1位为1，第2位为3、4、5、7、8中的一个，后面9位为0到9之间的任意数字。

如：使用数据"12345678901"进行匹配结果为false；使用数据"13312345678"进行匹配结果为true。

 

规则："a*b"

该规则需要匹配的内容是：在多个a或零个a后面有个b；b必须为最后一个字符。

如：使用数据"aaaaab"进行匹配结果为true；使用数据"abc"进行匹配结果为false。

字符串类中涉及正则表达式的常用方法
public boolean matches(String regex) //判断字符串是否匹配给定的规则

举例：校验qq号码.

1: 要求必须是5-15位数字

2: 0不能开头

代码演示：

String qq = "604154942";
String regex = "[1-9][0-9]{4,14}";
boolean flag2 = qq.matches(regex);
举例：校验手机号码

1：要求为11位数字

2：第1位为1，第2位为3、4、5、7、8中的一个，后面9位为0到9之间的任意数字。

代码演示：

String phone = "18800022116";
String regex = "1[34578][0-9]{9}";
boolean flag = phone.matches(regex);
public String[] split(String regex) //根据给定正则表达式的匹配规则，拆分此字符串

举例：分割出字符串中的的数字


代码演示：
String s = "18-22-40-65";
String regex = "-";
String[] result = s.split(regex);

代码演示：
String s = "18 22 40 65";
String regex = " ";
String[] result = s.split(regex);

public String replaceAll(String regex,String replacement)//将符合规则的字符串内容，全部替换为新字符串

举例：把文字中的数字替换成*

代码演示：

String s = "Hello12345World6789012";
String regex = "[0-9]";
String result = s.replaceAll(regex, "*");
正则表达式练习
匹配正确的数字，匹配规则：

匹配正整数：”\\d+”

匹配正小数：”\\d+\\.\\d+”  

匹配负整数：”-\\d+”

匹配负小数：”-\\d+\\.\\d+”

匹配保留两位小数的正数：”\\d+\\.\\d{2}”

匹配保留1-3位小数的正数：”\\d+\\.\\d{1,3}”

匹配合法的邮箱，匹配规则：

”[a-zA-Z_0-9]+@[a-zA-Z_0-9]+(\\.[a-zA-Z_0-9]+)+”

”\\w+@\\w+(\\.\\w+)+”

获取IP地址(192.168.1.100)中的每段数字，匹配规则：

　　”\\.”

Date
类 Date 表示特定的瞬间，精确到毫秒。

继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。

//创建日期对象，把当前的毫秒值转成日期对象
Date date = new Date(1607616000000L);
System.out.println(date);
//打印结果：Fri Dec 11 00:00:00 CST 2020
可是将毫秒值转成日期后，输出的格式不利于我们阅读，继续查阅API，Date中有getYear、getMouth等方法，可以他们已经过时，继续往下查阅，看到了toString方法。

点开toString()方法查阅，原来上面打印的date对象就是默认调用了这个toString方法，并且在这个方法下面还有让我们参见toLocaleString方法，点进去，这个方法又过时了，从 JDK 1.1 开始，由 DateFormat.format(Date date) 取代。既然这个方法被DateFormat.format(Date date) 取代，那么就要去查阅DateFormat类。

Date类常用方法
把日期对象转换成对应的时间毫秒值

  Date date = new Date();
  l=date.getTime();
  System.out.println(l);
毫秒的0点,时间原点; 公元1970年1月1日,午夜0:00:00 英国格林威治  毫秒值就是0

System.currentTimeMillis() 返回值long类型参数，用于获取当前日期的毫秒值 ，必须依赖毫秒值

DateFormat
DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 SimpleDateFormat类）允许进行格式化（也就是日期 -> 文本）、解析（文本-> 日期）和标准化。

我们通过这个类可以帮我们完成日期和文本之间的转换。

继续阅读API，DateFormat 可帮助进行格式化并解析任何语言环境的日期。对于月、星期，甚至日历格式（阴历和阳历），其代码可完全与语言环境的约定无关。

日期格式
要格式化一个当前语言环境下的日期也就是日期 -> 文本），要通过下面的方法来完成。DateFormat是抽象类，我们需要使用其子类SimpleDateFormat来创建对象。

构造方法



DateFormat类方法

 

代码演示：

//创建日期格式化对象,在获取格式化对象时可以指定风格
DateFormat df= new SimpleDateFormat("yyyy-MM-dd");//对日期进行格式化
Date date = new Date(1607616000000L);
String str_time = df.format(date);
System.out.println(str_time);//2020年12月11日
DateFormat类的作用：即可以将一个Date对象转换为一个符合指定格式的字符串，也可以将一个符合指定格式的字符串转为一个Date对象。

指定格式的具体规则我们可参照SimpleDateFormat类的说明，这里做简单介绍，规则是在一个字符串中，会将以下字母替换成对应时间组成部分，剩余内容原样输出：

当出现y时，会将y替换成年
当出现M时，会将M替换成月
当出现d时，会将d替换成日
当出现H时，会将H替换成时
当出现m时，会将m替换成分
当出现s时，会将s替换成秒
DateFormat类常用方法
format方法，用来将Date对象转换成String

parse方法，用来将String转换成Date（转换时，该String要符合指定格式，否则不能转换）。

代码演示：

练习一：把Date对象转换成String

Date date = new Date(1607616000000L);//Fri Dec 11 00:00:00 CST 2020
DateFormat df = new SimpleDateFormat(“yyyy年MM月dd日”);
String str = df.format(date);
//str中的内容为2020年12月11日
练习二：把String转换成Date对象

String str = ”2020年12月11日”;
DateFormat df = new SimpleDateFormat(“yyyy年MM月dd日”);
Date date = df.parse( str );
//Date对象中的内容为Fri Dec 11 00:00:00 CST 2020
Calendar
Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。

Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，将语言敏感内容处理好，再返回子类对象，如下：

Calendar类静态方法
Calendar c = Calendar.getInstance();  //返回当前时间

Calendar类常用方法
public static Calendar getInstance() //获取日期对象

public int get(int field)//获取时间字段值，字段参见帮助文档

YEAR 年

MONTH 月，从0开始算起，最大11；0代表1月，11代表12月。

DATE 天

HOUR 时

MINUTE分

SECOND秒

代码演示：

Calendar c = Calendar.getInstance();
int year = c.get(Calendar.YEAR);
public void add(int field,int amount)//指定字段增加某值

代码演示：

Calendar c = Calendar.getInstance();
//修改当前时间为3天后
c.add(Calendar.DATE, 3);
//修改当前时间为5小时后
c.add(Calendar.HOUR, 5);
public final void set(int field,int value)//设置指定字段的值

代码演示：

Calendar c = Calendar.getInstance();
//设置时间为2020年5月20日
c.set(Calendar.YEAR, 2020);
c.set(Calendar.MONTH, 4);
c.set(Calendar.DATE, 20);
public final Date getTime()//获取该日历对象转成的日期对象

代码演示：

Calendar c = Calendar.getInstance();
Date d = c.getTime();
注意事项

西方星期的开始为周日，中国为周一。
在Calendar类中，月份的表示是以0-11代表1-12月。
日期是有大小关系的，时间靠后，时间越大。
日期相关类练习
求出自己已经出生多少天

代码实现：


public static void main(String[] args) {
    Calendar my = Calendar.getInstance();
    //设置出生年月日 1995-05-10
    my.set(Calendar.YEAR, 1995);
    my.set(Calendar.MONTH, 4);
    my.set(Calendar.DATE, 10);
    //计算天数
    long day =(System.currentTimeMillis()-my.getTimeInMillis())/(24*60*60*1000L);
    System.out.println(day);
}
Java基础学习笔记十四 常用API之基本类型包装类
基本类型包装类
Java中有8种基本的数据类型，可是这些数据是基本数据，想对其进行复杂操作，变的很难。怎么办呢？
在实际程序使用中，程序界面上用户输入的数据都是以字符串类型进行存储的。而程序开发中，我们需要把字符串数据，根据需求转换成指定的基本数据类型，如年龄需要转换成int类型，考试成绩需要转换成double类型等。那么，想实现字符串与基本数据之间转换怎么办呢？
Java中提供了相应的对象来解决该问题，基本数据类型对象包装类：java将基本数据类型值封装成了对象。封装成对象有什么好处？可以提供更多的操作基本数值的功能。8种基本类型对应的包装类如下：



其中需要注意int对应的是Integer，char对应的Character，其他6个都是基本类型首字母大写即可。

基本数据类型对象包装类特点：用于在基本数据和字符串之间进行转换。

将字符串转成基本类型


parseXXX(String s);其中XXX表示基本类型，参数为可以转成基本类型的字符串，如果字符串无法转成基本类型，将会发生数字转换的问题 NumberFormatException

System.out.println(Integer.parseInt("123") + 2);
//打印结果为 125
将基本数值转成字符串
有3种方式：

基本类型直接与””相连接即可；34+""
调用String的valueOf方法；String.valueOf(34) ；


调用包装类中的toString方法；Integer.toString(34) ；


基本类型和对象转换
使用int类型与Integer对象转换进行演示，其他基本类型转换方式相同。

基本数值---->包装对象




Integer i = new Integer(4);//使用构造函数函数
Integer ii = new Integer("4");//构造函数中可以传递一个数字字符串

Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法
Integer iiii = Integer.valueOf("4");//使用包装类中的valueOf方法
包装对象---->基本数值


int num = i.intValue();
自动装箱拆箱
在需要的情况下，基本类型与包装类型可以通用。有些时候我们必须使用引用数据类型时，可以传入基本数据类型。
比如：
基本类型可以使用运算符直接进行计算，但是引用类型不可以。而基本类型包装类作为引用类型的一种却可以计算，原因在于，Java”偷偷地”自动地进行了对象向基本数据类型的转换。
相对应的，引用数据类型变量的值必须是new出来的内存空间地址值，而我们可以将一个基本类型的值赋值给一个基本类型包装类的引用。原因同样在于Java又”偷偷地”自动地进行了基本数据类型向对象的转换。
自动拆箱：对象转成基本数值
自动装箱：基本数值转成对象

Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);
i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5; 加法运算完成后，再次装箱，把基本数值转成对象。
自动装箱(byte常量池)细节

当数值在byte范围之内时，进行自动装箱，不会新创建对象空间而是使用已有的空间。


Integer a = new Integer(3);
Integer b = new Integer(3);
System.out.println(a==b);//false
System.out.println(a.equals(b));//true

System.out.println("---------------------");
Integer x = 127;
Integer y = 127;
//在jdk1.5自动装箱时，如果数值在byte范围之内，不会新创建对象空间而是使用原来已有的空间。
System.out.println(x==y); //true
System.out.println(x.equals(y)); //true

System类
在API中System类介绍的比较简单，我们给出定义，System中代表程序所在系统，提供了对应的一些系统属性信息，和系统操作。
System类不能手动创建对象，因为构造方法被private修饰，阻止外界创建对象。System类中的都是static方法，类名访问即可。在JDK中，有许多这样的类。
常用方法

currentTimeMillis() 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值

exit(int status) 用来结束正在运行的Java程序。参数传入一个数字即可。通常传入0记为正常状态，其他为异常状态

gc() 用来运行JVM中的垃圾回收器，完成内存中垃圾的清除。

getProperty(String key) 用来获取指定键(字符串名称)中所记录的系统属性信息



arraycopy方法，用来实现将源数组部分元素复制到目标数组的指定位置

System类的方法练习
验证for循环打印数字1-9999所需要使用的时间（毫秒）


public static void main(String[] args) {
        long start = System.currentTimeMillis();
        for (int i=0; i<10000; i++) {
            System.out.println(i);
        }
        long end = System.currentTimeMillis();
        System.out.println("共耗时毫秒：" + (end-start) );
    }

练习二：将src数组中前3个元素，复制到dest数组的前3个位置上

复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]
复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]


 public static void main(String[] args) {
        int[] src = new int[]{1,2,3,4,5};
        int[] dest = new int[]{6,7,8,9,10};
        System.arraycopy( src, 0, dest, 0, 3);
        //代码运行后：两个数组中的元素发生了变化

        //src数组元素[1,2,3,4,5]
        //dest数组元素[1,2,3,9,10]
    }

练习三：循环生成100-999之间的的三位数并进行打印该数，当该数能被10整除时，结束运行的程序


 public static void main(String[] args){
        Random random = new Random();
        while(true){
            int number = random.nextInt(900)+100; //0-899 + 100
            if (nmumber % 10 == 0) {
                System.exit(0);
            }
        }
    }

Math类
Math 类是包含用于执行基本数学运算的方法的数学工具类，如初等指数、对数、平方根和三角函数。
类似这样的工具类[工具类，代表能够完成一系列功能的类，在使用它们时，不用创建对象，该类中方法为静态方法]，其所有方法均为静态方法，并且一般不会创建对象。如System类

常用方法

abs方法,结果都为正数

double d1 = Math.abs(-5); // d1的值为5
double d2 = Math.abs(5); // d2的值为5
ceil方法，结果为比参数值大的最小整数的double值

double d1 = Math.ceil(3.3); //d1的值为 4.0
double d2 = Math.ceil(-3.3); //d2的值为 -3.0
double d3 = Math.ceil(5.1); // d3的值为 6.0
floor方法，结果为比参数值小的最大整数的double值

double d1 = Math.floor(3.3); //d1的值为3.0
double d2 = Math.floor(-3.3); //d2的值为-4.0
double d3 = Math.floor(5.1); //d3的值为 5.0
max方法，返回两个参数值中较大的值

double d1 = Math.max(3.3, 5.5); //d1的值为5.5
double d2 = Math.max(-3.3, -5.5); //d2的值为-3.3
min方法，返回两个参数值中较小的值

double d1 = Math.min(3.3, 5.5); //d1的值为3.3
double d2 = Math.max(-3.3, -5.5); //d2的值为-5.5
pow方法，返回第一个参数的第二个参数次幂的值

double d1 = Math.pow(2.0, 3.0); //d1的值为 8.0
double d2 = Math.pow(3.0, 3.0); //d2的值为27.0
round方法，返回参数值四舍五入的结果

double d1 = Math.round(5.5); //d1的值为6.0
double d2 = Math.round(5.4); //d2的值为5.0
random方法，产生一个大于等于0.0且小于1.0的double小数

double d1 = Math.random();
Arrays类
此类包含用来操作数组（比如排序和搜索）的各种方法。需要注意，如果指定数组引用为 null，则访问此类中的方法都会抛出空指针异常NullPointerException。

常用方法
sort方法，用来对指定数组中的元素进行排序（元素值从小到大进行排序）

//源arr数组元素{1,5,9,3,7}, 进行排序后arr数组元素为{1,3,5,7,9}
int[] arr = {1,5,9,3,7};
Arrays.sort( arr );
toString方法，用来返回指定数组元素内容的字符串形式

int[] arr = {1,5,9,3,7};
String str = Arrays.toString(arr); // str的值为[1, 3, 5, 7, 9]
binarySearch方法，在指定数组中，查找给定元素值出现的位置。若没有查询到，返回位置为-1。要求该数组必须是个有序的数组。

int[] arr = {1,3,4,5,6};
int index = Arrays.binarySearch(arr, 4); //index的值为2
int index2= Arrasy.binarySearch(arr, 2); //index2的值为-1
Arrays类的方法练习
练习一：定义一个方法，接收一个数组，数组中存储10个学生考试分数，该方法要求返回考试分数最低的后三名考试分数。


  public static int[] method(double[] arr){
        Arrays.sort(arr); //进行数组元素排序（元素值从小到大进行排序）
        int[] result = new int[3]; //存储后三名考试分数
        System.arraycopy(arr, 0, result, 0, 3);//把arr数组前3个元素复制到result数组中
        return result;
    }

大数据运算
BigInteger
java中long型为最大整数类型,对于超过long型的数据如何去表示呢.在Java的世界中,超过long型的整数已经不能被称为整数了,它们被封装成BigInteger对象.在BigInteger类中,实现四则运算都是方法来实现,并不是采用运算符.
BigInteger类的构造方法:
构造方法中,采用字符串的形式给出整数
四则运算代码：


  public static void main(String[] args) {
//大数据封装为BigInteger对象
        BigInteger big1 = new BigInteger("12345678909876543210");
        BigInteger big2 = new BigInteger("98765432101234567890");
//add实现加法运算
        BigInteger bigAdd = big1.add(big2);
//subtract实现减法运算
        BigInteger bigSub = big1.subtract(big2);
//multiply实现乘法运算
        BigInteger bigMul = big1.multiply(big2);
//divide实现除法运算
        BigInteger bigDiv = big2.divide(big1);
    }

BigDecimal
在程序中执行下列代码,会出现什么问题?

System.out.println(0.09 + 0.01);
System.out.println(1.0 - 0.32);
System.out.println(1.015 * 100);
System.out.println(1.301 / 100);
double和float类型在运算中很容易丢失精度,造成数据的不准确性,Java提供我们BigDecimal类可以实现浮点数据的高精度运算

构造方法如下:
建议浮点数据以字符串形式给出,因为参数结果是可以预知的
实现加法减法乘法代码如下:


 public static void main(String[] args) {
//大数据封装为BigDecimal对象
        BigDecimal big1 = new BigDecimal("0.09");
        BigDecimal big2 = new BigDecimal("0.01");
//add实现加法运算
        BigDecimal bigAdd = big1.add(big2);

        BigDecimal big3 = new BigDecimal("1.0");
        BigDecimal big4 = new BigDecimal("0.32");
//subtract实现减法运算
        BigDecimal bigSub = big3.subtract(big4);

        BigDecimal big5 = new BigDecimal("1.105");
        BigDecimal big6 = new BigDecimal("100");
//multiply实现乘法运算
        BigDecimal bigMul = big5.multiply(big6);
    }

对于浮点数据的除法运算,和整数不同,可能出现无限不循环小数,因此需要对所需要的位数进行保留和选择舍入模式
Java基础学习笔记十五 集合、迭代器、泛型
Collection
集合，集合是java中提供的一种容器，可以用来存储多个数据。
在前面的学习中，我们知道数据多了，可以使用数组存放或者使用ArrayList集合进行存放数据。那么，集合和数组既然都是容器，它们有啥区别呢？

数组的长度是固定的。集合的长度是可变的。
集合中存储的元素必须是引用类型数据
集合继承关系图
ArrayList的继承关系:

查看ArrayList类发现它继承了抽象类AbstractList同时实现接口List，而List接口又继承了Collection接口。Collection接口为最顶层集合接口了。
源代码：

interface List extends Collection {
}
public class ArrayList extends AbstractList implements List{
}
集合继承体系：

这说明我们在使用ArrayList类时，该类已经把所有抽象方法进行了重写。那么，实现Collection接口的所有子类都会进行方法重写。

Collecton接口常用的子接口有：List接口、Set接口
List接口常用的子类有：ArrayList类、LinkedList类
Set接口常用的子类有：HashSet类、LinkedHashSet类


Collection
集合Collection的方法，是集合中所有实现类必须拥有的方法

Object[] toArray() 集合中的元素,转成一个数组中的元素, 集合转成数组


      /*  Collection接口方法
       *  Object[] toArray() 集合中的元素,转成一个数组中的元素, 集合转成数组
       *  返回是一个存储对象的数组, 数组存储的数据类型是Object
       */
      private static void function_2() {
        Collection<String> coll = new ArrayList<String>();
        coll.add("abc");
        coll.add("itcast");
        coll.add("itheima");
        coll.add("money");
        coll.add("123");
        
        Object[] objs = coll.toArray();
        for(int i = 0 ; i < objs.length ; i++){
          System.out.println(objs[i]);
        }
      }

学习Java中三种长度表现形式：

数组.length 属性 返回值 int
字符串.length() 方法,返回值int
集合.size()方法, 返回值int
 boolean contains(Object o) 判断对象是否存在于集合中,对象存在返回true


      /*
       * Collection接口方法
       * boolean contains(Object o) 判断对象是否存在于集合中,对象存在返回true
       * 方法参数是Object类型
       */
      private static void function_1() {
        Collection<String> coll = new ArrayList<String>();
        coll.add("abc");
        coll.add("itcast");
        coll.add("itheima");
        coll.add("money");
        coll.add("123");
        
        boolean b = coll.contains("itcast");
        System.out.println(b);
      }

void clear() 清空集合中的所有元素


      /*
       * Collection接口的方法
       * void clear() 清空集合中的所有元素
       * 集合容器本身依然存在
       */
      public static void function(){
        //接口多态的方式调用
        Collection<String> coll = new ArrayList<String>();
        coll.add("abc");
        coll.add("bcd");
        System.out.println(coll);
        
        coll.clear();
        
        System.out.println(coll);
        
      }

boolean remove(Object o)移除集合中指定的元素


 /*
     * Collection接口方法
     * boolean remove(Object o)移除集合中指定的元素
     */
    private static void function_3(){
      Collection<String> coll = new ArrayList<String>();
      coll.add("abc");
      coll.add("money");
      coll.add("itcast");
      coll.add("itheima");
      coll.add("money");
      coll.add("123");  
      System.out.println(coll);
      
      boolean b = coll.remove("money");
      System.out.println(b);
      System.out.println(coll);
    }

迭代器
java中提供了很多个集合，它们在存储元素时，采用的存储方式不同，我们要取出这些集合中的元素，可通过一种通用的获取方式来完成。

Collection集合元素的通用获取方式：在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。

每种集合的底层的数据结构不同,例如ArrayList是数组,LinkedList底层是链表,但是无论使用哪种集合,我们都会判断是否有元素，以及取出里面的元素的动作,那么Java为我们提供一个迭代器定义了统一的判断元素和取元素的方法。

 迭代器的实现原理
 集合中的迭代器:获取集合中元素方式

接口 Iterator : 两个抽象方法
boolean hasNext() 判断集合中还有没有可以被取出的元素,如果有返回true
next() 取出集合中的下一个元素
Iterator接口,找实现类.
Collection接口定义方法：Iterator  iterator()  


ArrayList 重写方法 iterator(),返回了Iterator接口的实现类的对象




 使用ArrayList集合的对象

Iterator it =array.iterator(),运行结果就是Iterator接口的实现类的对象
it是接口的实现类对象,调用方法 hasNext 和 next 集合元素迭代
 迭代器的代码实现 

package cn.itcast.demo;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

/*
 *  集合中的迭代器:
 *    获取集合中元素方式
 *  接口 Iterator : 两个抽象方法
 *     boolean hasNext() 判断集合中还有没有可以被取出的元素,如果有返回true
 *     next() 取出集合中的下一个元素
 *     
 *  Iterator接口,找实现类.
 *    Collection接口定义方法 
 *       Iterator  iterator()
 *    ArrayList 重写方法 iterator(),返回了Iterator接口的实现类的对象
 *    使用ArrayList集合的对象
 *     Iterator it = array.iterator(),运行结果就是Iterator接口的实现类的对象
 *     it是接口的实现类对象,调用方法 hasNext 和 next 集合元素迭代
 */
public class IteratorDemo {
    public static void main(String[] args) {
        Collection<String> coll = new ArrayList<String>();
        coll.add("abc1");
        coll.add("abc2");
        coll.add("abc3");
        coll.add("abc4");
        //迭代器,对集合ArrayList中的元素进行取出
        
        //调用集合的方法iterator()获取出,Iterator接口的实现类的对象
        Iterator<String> it = coll.iterator();
        //接口实现类对象,调用方法hasNext()判断集合中是否有元素
        //boolean b = it.hasNext();
        //System.out.println(b);
        //接口的实现类对象,调用方法next()取出集合中的元素
        //String s = it.next();
        //System.out.println(s);
        
        //迭代是反复内容,使用循环实现,循环的条件,集合中没元素, hasNext()返回了false
        while(it.hasNext()){
            String s = it.next();
            System.out.println(s);
        }
        
        /*for (Iterator<String> it2 = coll.iterator(); it2.hasNext();  ) {
            System.out.println(it2.next());
        }*/
        
    }
}

迭代器的执行过程

 while(it.hasNext()) {
            System.out.println(it.next());
       }
       
       //cursor记录的索引值不等于集合的长度返回true,否则返回false
         public boolean hasNext() {       
           return cursor != size; //cursor初值为0
                           
         }

        //next()方法作用:
        //①返回cursor指向的当前元素 
        //②cursor++
        public Object next() {            
                 int i = cursor; 
                 cursor = i + 1;  
                 return  elementData[lastRet = i]; 
             
             }
     //for循环迭代写法:
        for (Iterator<String> it2 = coll.iterator(); it2.hasNext();  ) {
         System.out.println(it2.next());
       } 

集合迭代中的转型 
在使用集合时，我们需要注意以下几点：

1、集合中存储的其实都是对象的地址。

2、集合中可以存储基本数值吗？jdk1.5版本以后可以存储了。因为出现了基本类型包装类，它提供了自动装箱操作（基本类型对象），这样，集合中的元素就是基本数值的包装类对象。

3、存储时提升了Object。取出时要使用元素的特有内容，必须向下转型。  注意：如果集合中存放的是多个对象，这时进行向下转型会发生类型转换异常。


 Collection coll = new ArrayList();
     coll.add("abc");
     coll.add("aabbcc");
     coll.add("shitcast");
     Iterator it = coll.iterator();
     while (it.hasNext()) {
      //由于元素被存放进集合后全部被提升为Object类型
     //当需要使用子类对象特有方法时，需要向下转型
      String str = (String) it.next();
      System.out.println(str.length());
}

4、Iterator接口也可以使用<>来控制迭代元素的类型的。代码演示如下： 


 Collection<String> coll = new ArrayList<String>();
     coll.add("abc");
     coll.add("aabbcc");
     coll.add("shitcast");
     Iterator<String> it = coll.iterator();
     while (it.hasNext()) {
      String str =  it.next(); 
     //当使用Iterator<String>控制元素类型后，就不需要强转了。获取到的元素直接就是String类型
      System.out.println(str.length());
}

增强for循环遍历数组

  /*
      *  JDK1.5新特性,增强for循环
      *  JDK1.5版本后,出现新的接口 java.lang.Iterable
      *    Collection开是继承Iterable
      *    Iterable作用,实现增强for循环
      *    
      *    格式:
      *      for( 数据类型  变量名 : 数组或者集合 ){
      *         sop(变量);
      *      }
      */
     public static void function_1(){
        //for对于对象数组遍历的时候,能否调用对象的方法呢
        String[] str = {"abc","itcast","cn"};
        for(String s : str){
          System.out.println(s.length());
        }
      }


/*
       *  实现for循环,遍历数组
       *  好处: 代码少了,方便对容器遍历
       *  弊端: 没有索引,不能操作容器里面的元素
       */
      public static void function(){
        int[] arr = {3,1,9,0};
        for(int i : arr){
          System.out.println(i+1);
        }
        System.out.println(arr[0]);
      }

增强for循环遍历集合  

        /*
         *  增强for循环遍历集合
         *  存储自定义Person类型
         */
        public static void function_2(){
          ArrayList<Person> array = new ArrayList<Person>();
          array.add(new Person("a",20));
          array.add(new Person("b",10));
          for(Person p : array){
            System.out.println(p);// System.out.println(p.toString());
          }
        }


 

泛型
泛型的引入
 在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。比如下面程序：

 


public class GenericDemo {
  public static void main(String[] args) {
    List list = new ArrayList();
    list.add("abc");
    list.add("itcast");
    list.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放
                //相当于:Object obj=new Integer(5);
    
    Iterator it = list.iterator();
    while(it.hasNext()){
      //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型
      String str = (String) it.next();//String str=(String)obj;
                                      //编译时期仅检查语法错误,String是Object的儿子可以向下转型
                                      //运行时期String str=(String)(new Integer(5))
                                      //String与Integer没有父子关系所以转换失败
                                      //程序在运行时发生了问题java.lang.ClassCastException
      System.out.println(str.length());
    }
  }
}

泛型的定义和使用
JDK1.5 出现新的安全机制,保证程序的安全性，泛型指明了集合中存储数据的类型  <数据类型>


public class GenericDemo {
      public static void main(String[] args) {
        function();
      }
      
      public static void function(){
        Collection<String> coll = new ArrayList<String>();
        coll.add("abc");
        coll.add("rtyg");
        coll.add("43rt5yhju");
    //    coll.add(1);
        
        Iterator<String> it = coll.iterator();
        while(it.hasNext()){
          String s = it.next();
          System.out.println(s.length());
        }
      }
    }

Java中的伪泛型
Java中的伪泛型：泛型只在编译时存在,编译后就被擦除,在编译之前我们就可以限制集合的类型,起到作用
例如:ArrayList<String> al=new ArrayList<String>(); 编译后:ArrayList al=new ArrayList();

泛型类
定义格式： 修饰符 class 类名<代表泛型的变量> { } 

 class ArrayList<E>{ 
        public boolean add(E e){ }
        public E get(int index){  }
      }
使用格式：创建对象时，确定泛型的类型


//例如，ArrayList<String> list = new ArrayList<String>();      
//此时，变量E的值就是String类型
class ArrayList<String>{
    public boolean add(String e){ }
    public String get(int index){  }
}

//例如，ArrayList<Integer> list = new ArrayList<Integer>();
//此时，变量E的值就是Integer类型
class ArrayList<Integer>{
    public boolean add(Integer e){ }
    public Integer get(int index){  }
}

泛型方法
定义格式： 修饰符 <代表泛型的变量> 返回值类型 方法名(参数){ } 

泛型方法的使用：

例如，API中的ArrayList集合中的方法：

 public <T> T[] toArray(T[] a){  } 
 //该方法，用来把集合元素存储到指定数据类型的数组中，返回已存储集合元素的数组
使用格式：调用方法时，确定泛型的类型


//例如:
ArrayList<String> list = new ArrayList<String>();
String[] arr = new String[100];
String[] result = list.toArray(arr);
//此时，变量T的值就是String类型。变量T，可以与定义集合的泛型不同
public <String> String[] toArray(String[] a){  }

//例如:
ArrayList<String> list = new ArrayList<String>();
Integer[] arr = new Integer[100];
Integer [] result = list.toArray(arr);

//此时，变量T的值就是Integer类型。变量T，可以与定义集合的泛型不同
public <Integer> Integer[] toArray(Integer[] a){  } 

泛型接口

/*
 *  带有泛型的接口
 *  
 *  public interface List <E>{
 *    abstract boolean add(E e);
 *  }
 * 
 *  实现类,先实现接口,不理会泛型
 *  public class ArrayList<E> implements List<E>{
 *  }
 *  调用者 : new ArrayList<String>() 后期创建集合对象的时候,指定数据类型
 *  
 *  
 *  实现类,实现接口的同时,也指定了数据类型
 *  public class XXX implements List<String>{
 *  }
 *  new XXX()
 */

泛型的好处
将运行时期的ClassCastException，转移到了编译时期。
避免了类型强转的麻烦。


public class GenericDemo {
      public static void main(String[] args) {
        List<String> list = new ArrayList<String>();
        list.add("abc");
        list.add("itcast");
        //list.add(5);//当集合明确类型后，存放类型不一致就会编译报错
                     //集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型
       
        Iterator<String> it = list.iterator();
        while(it.hasNext()){
           String str = it.next();
           System.out.println(str.length()); //当使用Iterator<String>      
                                            //控制元素类型后，就不需要强转了。获取到的元素直接就是String类型
        }
      }
    }

泛型的通配符   
? 泛型的通配,匹配所有的数据类型

/*
   *  泛型的通配符
   */
public class GenericDemo {
    public static void main(String[] args) {
        ArrayList<String> array = new ArrayList<String>();

        HashSet<Integer> set = new HashSet<Integer>();

        array.add("123");
        array.add("456");

        set.add(789);
        set.add(890);

        iterator(array);
        iterator(set);
    }
    /*
     *  定义方法,可以同时迭代2个集合
     *  参数: 怎么实现 , 不能写ArrayList,也不能写HashSet
     *  参数: 或者共同实现的接口
     *  泛型的通配,匹配所有的数据类型  ?
     */
    public static void iterator(Collection<?> coll){
        Iterator<?> it = coll.iterator();
        while(it.hasNext()){
            //it.next()获取的对象,什么类型
            System.out.println(it.next());
        }
    }
}

泛型的限定 
? extends Employee 限制的是父类, 上限限定
? super   Employee 限制的是子类, 下限限定

 /*
    *  将的酒店员工,厨师,服务员,经理,分别存储到3个集合中
    *  定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法
    */
   import java.util.ArrayList;
   import java.util.Iterator;

public class GenericTest {
    public static void main(String[] args) {
        //创建3个集合对象
        ArrayList<ChuShi> cs = new ArrayList<ChuShi>();
        ArrayList<FuWuYuan> fwy = new ArrayList<FuWuYuan>();
        ArrayList<JingLi> jl = new ArrayList<JingLi>();

        //每个集合存储自己的元素
        cs.add(new ChuShi("张三", "后厨001"));
        cs.add(new ChuShi("李四", "后厨002"));

        fwy.add(new FuWuYuan("翠花", "服务部001"));
        fwy.add(new FuWuYuan("酸菜", "服务部002"));

        jl.add(new JingLi("小名", "董事会001", 123456789.32));
        jl.add(new JingLi("小强", "董事会002", 123456789.33));

        //   ArrayList<String> arrayString = new ArrayList<String>();
        iterator(jl);
        iterator(fwy);
        iterator(cs);

    }

    /*
     * 定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法 work
     * ? 通配符,迭代器it.next()方法取出来的是Object类型,怎么调用work方法
     * 强制转换:  it.next()=Object o ==> Employee
     * 方法参数: 控制,可以传递Employee对象,也可以传递Employee的子类的对象
     * 泛型的限定  本案例,父类固定Employee,但是子类可以无限?
     *   ? extends Employee 限制的是父类, 上限限定, 可以传递Employee,传递他的子类对象
     *   ? super   Employee 限制的是子类, 下限限定, 可以传递Employee,传递他的父类对象
     */
    public static void iterator(ArrayList<? extends Employee> array) {
        Iterator<? extends Employee> it = array.iterator();
        while (it.hasNext()) {
            //获取出的next() 数据类型,是什么Employee
            Employee e = it.next();
            e.work();
        }
    }
}
Java基础学习笔记十六 集合框架（二）
List
List接口的特点:

它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的。
它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。
集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。
List接口的常用子类有：

ArrayList集合
LinkedList集合
List接口的特有方法(带索引的方法)
1、增加元素方法

add(Object e)：向集合末尾处，添加指定的元素
add(int index, Object e) 向集合指定索引处，添加指定的元素，原有元素依次后移

/*
* add(int index, E)
* 将元素插入到列表的指定索引上
* 带有索引的操作,防止越界问题
* java.lang.IndexOutOfBoundsException
* ArrayIndexOutOfBoundsException
* StringIndexOutOfBoundsException
*/
public static void function(){
        List<String> list=new ArrayList<String>();
        list.add("abc1");
        list.add("abc2");
        list.add("abc3");
        list.add("abc4");
        System.out.println(list);

        list.add(1,"itcast");
        System.out.println(list);
}

2、删除元素

remove(Object e)：将指定元素对象，从集合中删除，返回值为被删除的元素
remove(int index)：将指定索引处的元素，从集合中删除，返回值为被删除的元素

/*
* E remove(int index)
* 移除指定索引上的元素
* 返回被删除之前的元素
*/
public static void function_1(){
        List<Double> list = new ArrayList<Double>();
        list.add(1.1);
        list.add(1.2);
        list.add(1.3);
        list.add(1.4);

        Double d = list.remove(0);
        System.out.println(d);
        System.out.println(list);
} 

3、替换元素方法
set(int index, Object e)：将指定索引处的元素，替换成指定的元素，返回值为替换前的元素

/*
* E set(int index, E)
* 修改指定索引上的元素
* 返回被修改之前的元素
*/
public static void function_2(){
        List<Integer> list = new ArrayList<Integer>();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);

        Integer i = list.set(0, 5);
        System.out.println(i);
        System.out.println(list);
}

查询元素方法

get(int index)：获取指定索引处的元素，并返回该元素

迭代器的并发修改异常
迭代器的并发修改异常 java.util.ConcurrentModificationException就是在遍历的过程中,使用了集合方法修改了集合的长度,这是不允许的。


import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ListDemo1 {
public static void main(String[] args) {
        List<String> list = new ArrayList<String>();
        list.add("abc1");
        list.add("abc2");
        list.add("abc3");
        list.add("abc4");

//对集合使用迭代器进行获取,获取时候判断集合中是否存在 "abc3"对象
//如果有,添加一个元素 "ABC3"
        Iterator<String> it = list.iterator();
        while(it.hasNext()){
            String s = it.next();
//对获取出的元素s,进行判断,是不是有"abc3"
            if(s.equals("abc3")){
                list.add("ABC3");
            }
            System.out.println(s);
        }
    }
}

运行结果：


Exception in thread "main" abc1
abc2
abc3
java.util.ConcurrentModificationException
    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901)
    at java.util.ArrayList$Itr.next(ArrayList.java:851)
    at ArrayListDemo.main(ArrayListDemo.java:17)

运行上述代码发生了错误 java.util.ConcurrentModificationException这是什么原因呢？在迭代过程中，使用了集合的方法对元素进行操作。导致迭代器并不知道集合中的变化，容易引发数据的不确定性。

并发修改异常解决办法：在迭代时，不要使用集合的方法操作元素。或者通过ListIterator迭代器操作元素是可以的，ListIterator的出现，解决了使用Iterator迭代过程中可能会发生的错误情况。

数据的存储结构
 栈 结 构：后进先出/先进后出(手枪弹夹) FILO (first in last out)

队列结构：先进先出/后进后出(银行排队) FIFO(first in first out)

数组结构：查询快，通过索引快速找到元素；增删慢:每次增删都需要开辟新的数组,将老数组中的元素拷贝到新数组中；开辟新数组耗费资源。

链表结构：查询慢，每次都需要从链头或者链尾找起；增删快，只需要修改元素记录的下个元素的地址值即可不需要移动大量元素

ArrayList集合的自身特点
底层采用的是数组结构


ArrayList al=new ArrayList();//创建了一个长度为0的Object类型数组
al.add("abc");//底层会创建一个长度为10的Object数组 Object[] obj=new Object[10]
//obj[0]="abc"
//如果添加的元素的超过10个,底层会开辟一个1.5*10的长度的新数组
//把原数组中的元素拷贝到新数组,再把最后一个元素添加到新数组中
//原数组:a b c d e f g h k l
//添加m:a b c d e f g h k l m null null null null

LinkedList集合的自身特点
底层采用链表结构,每次查询都要从链头或链尾找起,查询相对数组较慢，但是删除直接修改元素记录的地址值即可,不要大量移动元素
LinkedList的索引决定是从链头开始找还是从链尾开始找，如果该元素小于元素长度一半,从链头开始找起,如果大于元素长度的一半,则从链尾找起

LinkedList特有方法:获取,添加,删除


/*
* LinkedList 链表集合的特有功能
* 自身特点: 链表底层实现,查询慢,增删快
* 
* 子类的特有功能,不能多态调用
*/
public class LinkedListDemo {
    public static void main(String[] args) {
        function_3();
    }
    /*
    * E removeFirst() 移除并返回链表的开头
    * E removeLast() 移除并返回链表的结尾
    */
    public static void function_3(){
        LinkedList<String> link = new LinkedList<String>();
        link.add("1");
        link.add("2");
        link.add("3");
        link.add("4");

        String first = link.removeFirst();
        String last = link.removeLast();
        System.out.println(first);
        System.out.println(last);

        System.out.println(link);
    }

    /*
    * E getFirst() 获取链表的开头
    * E getLast() 获取链表的结尾
    */
    public static void function_2(){
        LinkedList<String> link = new LinkedList<String>();
        link.add("1");
        link.add("2");
        link.add("3");
        link.add("4");

        if(!link.isEmpty()){
            String first = link.getFirst();
            String last = link.getLast();
            System.out.println(first);
            System.out.println(last);
        }
    }

    public static void function_1(){
        LinkedList<String> link = new LinkedList<String>();
        link.addLast("a");
        link.addLast("b");
        link.addLast("c");
        link.addLast("d");

        link.addFirst("1");
        link.addFirst("2");
        link.addFirst("3");
        System.out.println(link);
    }

    /*
    * addFirst(E) 添加到链表的开头
    * addLast(E) 添加到链表的结尾
    */
    public static void function(){
        LinkedList<String> link = new LinkedList<String>();

        link.addLast("heima");

        link.add("abc");
        link.add("bcd");

        link.addFirst("itcast");
        System.out.println(link);
    }
}

Vector
Vector集合数据存储的结构是数组结构，为JDK中最早提供的集合,它是线程同步的。

Vector中提供了一个独特的取出方式，就是枚举Enumeration，它其实就是早期的迭代器。

此接口Enumeration的功能与 Iterator 接口的功能是类似的。
Vector集合已被ArrayList替代。枚举Enumeration已被迭代器Iterator替代。

Set
Set接口的特点
它是个不包含重复元素的集合。
Set集合取出元素的方式可以采用：迭代器、增强for。
Set集合有多个子类，这里我们介绍其中的HashSet、LinkedHashSet这两个集合。 


/*
* Set接口,特点不重复元素,没索引
* 
* Set接口的实现类,HashSet (哈希表)
* 特点: 无序集合,存储和取出的顺序不同,没有索引,不存储重复元素
* 代码的编写上,和ArrayList完全一致
*/
public class HashSetDemo {
    public static void main(String[] args) {
        Set<String> set = new HashSet<String>();
        set.add("cn");
        set.add("heima");
        set.add("java");
        set.add("java");
        set.add("itcast");

        Iterator<String> it = set.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
        System.out.println("==============");

        for(String s : set){
            System.out.println(s);
        }
    }
}

哈希表的数据结构
加载因子:表中填入的记录数/哈希表的长度

例如:加载因子是0.75 代表：数组中的16个位置,其中存入16*0.75=12个元素

如果在存入第十三个(>12)元素,导致存储链子过长,会降低哈希表的性能,那么此时会扩充哈希表(在哈希),底层会开辟一个长度为原长度2倍的数组,把老元素拷贝到新数组中,再把新元素添加数组中
当存入元素数量>哈希表长度*加载因子,就要扩容,因此加载因子决定扩容时机

字符串对象的哈希值 

/*
 *  对象的哈希值,普通的十进制整数
 *  父类Object,方法 public int hashCode() 计算结果int整数
 */
public class HashDemo {
    public static void main(String[] args) {
        String s1 = new String("abc");
        String s2 = new String("abc");
        System.out.println(s1.hashCode());//96354
        System.out.println(s2.hashCode());//96354

        System.out.println("重地".hashCode());//1179395
        System.out.println("通话".hashCode());//1179395
    }
}


//String类重写hashCode()方法
//字符串都会存储在底层的value数组中{'a','b','c'}
public int hashCode() {
    int h = hash;
    if (h == 0 && value.length > 0) {
        char val[] = value;

        for (int i = 0; i < value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
}



哈希表的存储过程

public static void main(String[] args) {
    HashSet<String> set = new HashSet<String>();
    set.add(new String("abc"));
    set.add(new String("abc"));
    set.add(new String("bbc"));
    set.add(new String("bbc"));
    System.out.println(set);
}

存取原理，每存入一个新的元素都要走以下三步:

1.首先调用本类的hashCode()方法算出哈希值

2.在容器中找是否与新元素哈希值相同的老元素,如果没有直接存入；如果有转到第三步

3.新元素会与该索引位置下的老元素利用equals方法一一对比，一旦新元素.equals(老元素)返回true,停止对比,说明重复,不再存入，如果与该索引位置下的老元素都通过equals方法对比返回false,说明没有重复,存入。hashCode()返回一个是十进制的值,这个值叫做哈希值,不同的类都会重写Object类的hashCode()方法,底层有不同的生成哈希值的算法,下面介绍如何通过hashCode()方法和equals()方法保证存入HashSet的值唯一的。



哈希表的存储自定义对象

/*
* HashSet集合的自身特点:
* 底层数据结构,哈希表
* 存储,取出都比较快
* 线程不安全,运行速度快
*/
public class HashSetDemo1 {
    public static void main(String[] args) {

//将Person对象中的姓名,年龄,相同数据,看作同一个对象
//判断对象是否重复,依赖对象自己的方法 hashCode,equals
        HashSet<Person> setPerson = new HashSet<Person>();
        setPerson.add(new Person("a",11));
        setPerson.add(new Person("b",10));
        setPerson.add(new Person("b",10));
        setPerson.add(new Person("c",25));
        setPerson.add(new Person("d",19));
        setPerson.add(new Person("e",17));//每个对象的地址值都不同,调用Obejct类的hashCode方法返回不同哈希值,直接存入
        System.out.println(setPerson);
    }
}


public class Person {
    private String name;
    private int age;

    /*
    * 没有做重写父类,每次运行结果都是不同整数
    * 如果子类重写父类的方法,哈希值,自定义的
    * 存储到HashSet集合的依据
    * 
    * 尽可能让不同的属性值产生不同的哈希值,这样就不用再调用equals方法去比较属性
    *
    */
    public int hashCode(){
        return name.hashCode()+age*55;
    }
    //方法equals重写父类,保证和父类相同
//public boolean equals(Object obj){}
    public boolean equals(Object obj){
        if(this == obj)
            return true;
        if(obj == null)
            return false;
        if(obj instanceof Person){
            Person p = (Person)obj;
            return name.equals(p.name) && age==p.age;
        }
        return false;
    }

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }
    public Person(){}

    public String toString(){
        return name+".."+age;
    }
}


LinkedHashSet集合
LinkedHashSet 基于链表的哈希表实现，继承自HashSet。

LinkedHashSet 自身特性：

具有顺序,存储和取出的顺序相同的；
线程不安全的集合,运行速度块

public class LinkedHashSetDemo {
    public static void main(String[] args) {
        LinkedHashSet<Integer> link = new LinkedHashSet<Integer>();
        link.add(123);
        link.add(44);
        link.add(33);
        link.add(33);
        link.add(66);
        link.add(11);
        System.out.println(link);
    }
}

ArrayList,HashSet判断对象是否重复的原因
ArrayList的contains方法原理:底层依赖于equals方法，ArrayList的contains方法调用时，会使用传入元素的equals方法依次与集合中的旧元素所比较，从而根据返回的布尔值判断是否有重复元素。

此时，当ArrayList存放自定义类型时，由于自定义类型在未重写equals方法前，判断是否重复的依据是地址值，所以如果想根据内容判断是否为重复元素，需要重写元素的equals方法。HashSet的add()方法和contains方法()底层都依赖 hashCode()方法与equals方法()。

Set集合不能存放重复元素，其添加方法在添加时会判断是否有重复元素，有重复不添加，没重复则添加。

HashSet集合由于是无序的，其判断唯一的依据是元素类型的hashCode与equals方法的返回结果。规则如下：

先判断新元素与集合内已经有的旧元素的HashCode值，如果不同，说明是不同元素，添加到集合。如果相同，再判断equals比较结果。返回true则相同元素；返回false则不同元素，添加到集合。

所以，使用HashSet存储自定义类型，如果没有重写该类的hashCode与equals方法，则判断重复时，使用的是地址值，如果想通过内容比较元素是否相同，需要重写该元素类的hashcode与equals方法。

hashCode和equals的面试题
两个对象 Person p1 p2，如果两个对象的哈希值相同 p1.hashCode()==p2.hashCode()，两个对象的equals一定返回true吗？ 即p1.equals(p2) 一定是true吗？

正确答案:不一定

如果两个对象的equals方法返回true,p1.equals(p2)==true，两个对象的哈希值一定相同吗？

正确答案: 一定

Java对于eqauls方法和hashCode方法是这样规定的：     

1.如果两个对象相同，那么它们的hashCode值一定要相同；
2.如果两个对象的hashCode相同，它们并不一定相同（这里说的对象相同指的是用eqauls方法比较）。如不按要求去做了，会发现相同的对象可以出现在Set集合中，同时，增加新元素的效率会大大下降。
3.equals()相等的两个对象，hashcode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。换句话说，equals()方法不相等的两个对象，hashcode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。反过来，hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。
Java基础学习笔记十七 集合框架（三）之Map
Map接口
通过查看Map接口描述，发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同，如下图。



Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。

Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。

Collection中的集合称为单列集合，Map中的集合称为双列集合。

需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。

Map中常用的集合为HashMap集合、LinkedHashMap集合。

Map接口中常用集合概述
通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。

HashMap<K,V>：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。
LinkedHashMap<K,V>：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。
注意：Map接口中的集合都有两个泛型变量<K,V>,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量<K,V>的数据类型可以相同，也可以不同。

Map接口中的常用方法


put方法：将指定的键与值对应起来，并添加到集合中，方法返回值为键所对应的值。

使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中；
使用put方法时，若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。
get方法：获取指定键(key)所对应的值(value)

remove方法：根据指定的键(key)删除元素，返回被删除元素的值(value)。

Map接口的方法演示


public class MapDemo {
    public static void main(String[] args) {
//创建Map对象
        Map<String, String> map = new HashMap<String,String>();
//给map中添加元素
        map.put("星期一", "Monday");
        map.put("星期日", "Sunday");
        System.out.println(map); // {星期日=Sunday, 星期一=Monday}
//当给Map中添加元素，会返回key对应的原来的value值，若key没有对应的值，返回null
        System.out.println(map.put("星期一", "Mon")); // Monday
        System.out.println(map); // {星期日=Sunday, 星期一=Mon}
//根据指定的key获取对应的value
        String en = map.get("星期日");
        System.out.println(en); // Sunday
//根据key删除元素,会返回key对应的value值
        String value = map.remove("星期日");
        System.out.println(value); // Sunday
        System.out.println(map); // {星期一=Mon}
    }
}

Map集合遍历键找值方式
键找值方式：即通过元素中的键，获取键所对应的值。

操作步骤与图解：

1.获取Map集合中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键
         

2.遍历键的Set集合，得到每一个键
3.根据键，获取键所对应的值


代码演示：


public class MapDemo {
    public static void main(String[] args) {
//创建Map对象
        Map<String, String> map = new HashMap<String,String>();
//给map中添加元素
        map.put("邓超", "孙俪");
        map.put("李晨", "范冰冰");
        map.put("刘德华", "柳岩");
//获取Map中的所有key
        Set<String> keySet = map.keySet();
//遍历存放所有key的Set集合
        Iterator<String> it =keySet.iterator();
        while(it.hasNext()){
//得到每一个key
            String key = it.next();
//通过key获取对应的value
            String value = map.get(key);
            System.out.println(key+"="+value);
        }
    }
}

Entry键值对对象




在Map类设计时，提供了一个嵌套接口：Entry。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。

Entry是Map接口中提供的一个静态内部嵌套接口。

getKey()方法：获取Entry对象中的键
getValue()方法：获取Entry对象中的值
entrySet()方法：用于返回Map集合中所有的键值对(Entry)对象，以Set集合形式返回。
Map集合遍历键值对方式
键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。

操作步骤与图解：

1.获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。
　　　　

2.遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象
3.通过键值对(Entry)对象，获取Entry对象中的键与值。
　　　　


public class MapDemo {
    public static void main(String[] args) {
//创建Map对象
        Map<String, String> map = new HashMap<String,String>();
//给map中添加元素
        map.put("邓超", "孙俪");
        map.put("李晨", "范冰冰");
        map.put("刘德华", "柳岩");
//获取Map中的所有key与value的对应关系
        Set<Map.Entry<String,String>> entrySet = map.entrySet();
//遍历Set集合
        Iterator<Map.Entry<String,String>> it =entrySet.iterator();
        while(it.hasNext()){
//得到每一对对应关系
            Map.Entry<String,String> entry = it.next();
//通过每一对对应关系获取对应的key
            String key = entry.getKey();
//通过每一对对应关系获取对应的value
            String value = entry.getValue();
            System.out.println(key+"="+value);
        }
    }
}

注意：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。
HashMap存储自定义类型键值
练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。

注意，学生姓名相同并且年龄相同视为同一名学生。

学生类


public class Student {
    private String name;
    private int age;
//编写构造方法，文档中已省略
//编写get,set方法，文档中已省略
//编写toString方法，文档中已省略
}

测试类


public class HashMapTest {
    public static void main(String[] args) {
//1,创建hashmap集合对象。
        Map<Student,String> map = new HashMap<Student,String>();
//2,添加元素。
        map.put(new Student("lisi",28), "上海");
        map.put(new Student("wangwu",22), "北京");
        map.put(new Student("zhaoliu",24), "成都");
        map.put(new Student("zhouqi",25), "广州");
        map.put(new Student("wangwu",22), "南京");
//3,取出元素。键找值方式
        Set<Student> keySet = map.keySet();
        for(Student key : keySet){
            String value = map.get(key);
            System.out.println(key.toString()+"....."+value);
        }
//取出元素。键值对方式
        Set<Map.Entry<Student, String>> entrySet = map.entrySet();
        for (Map.Entry<Student, String> entry : entrySet) {
            Student key = entry.getKey();
            String value = entry.getValue();
            System.out.println(key.toString()+"....."+value);
        }
    }
}

当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。

如果要保证map中存放的key和取出的顺序一致，可以使用LinkedHashMap集合来存放。

静态导入
在导包的过程中我们可以直接导入静态部分，这样某个类的静态成员就可以直接使用了。在源码中经常会出现静态导入。

静态导入格式： import static XXX.YYY;  ，导入后YYY可直接使用。

例如：Map.Entry的访问，简化后为Entry


import static java.util.Map.Entry;
public class HashMapTest {
    public static void main(String[] args) {
//1,创建hashmap集合对象。
        Map<Student,String> map = new HashMap<Student,String>();
//取出元素。键值对方式
//Set<Map.Entry<Student, String>> entrySet = map.entrySet();
        Set<Entry<Student, String>> entrySet = map.entrySet();
//for (Map.Entry<Student, String> entry : entrySet) {
        for (Entry<Student, String> entry : entrySet) {
            Student key = entry.getKey();
            String value = entry.getValue();
            System.out.println(key.toString()+"....."+value);
        }
    }
}

可变参数
在JDK1.5之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：

修饰符 返回值类型 方法名(参数类型... 形参名){ }
其实这个书写完全等价与

修饰符 返回值类型 方法名(参数类型[] 形参名){ }
只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。jdk1.5以后。出现了简化操作。... 用在参数上，称之为可变参数。

同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。

代码演示：


public class ParamDemo {
    public static void main(String[] args) {
        int[] arr = {21,89,32};
        int sum = add(arr);
        System.out.println(sum);
        sum = add(21,89,32);//可变参数调用形式
        System.out.println(sum);
    }
//JDK1.5之后写法
    public static int add(int...arr){
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];
        }
        return sum;
    }
//原始写法
/*
public static int add(int[] arr) {
int sum = 0;
for (int i = 0; i < arr.length; i++) {
sum += arr[i];
}
return sum;
}
*/
}

上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性

注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。
Collections集合工具类
Collections是集合工具类，用来对集合进行操作。部分方法如下：


public static <T> void sort(List<T> list) // 集合元素排序
//排序前元素list集合元素 [33,11,77,55]
Collections.sort( list );
//排序后元素list集合元素 [11,33,55,77]
public static void shuffle(List<?> list) // 集合元素存储位置打乱
//list集合元素 [11,33,55,77]
Collections.shuffle( list );
//使用shuffle方法后，集合中的元素为[77,33,11,55]，每次执行该方法，集合中存储的元素位置都会随机打乱

集合嵌套
集合嵌套并不是一个新的知识点，仅仅是集合内容又是集合，如Collection集合嵌套、Collection集合与Map集合相互嵌套、Map集合嵌套。

ArrayList嵌套 ArrayList：ArrayList< ArrayList<String> >、Collection< ArrayList<Integer> >

Map嵌套 ArrayList：HashMap<String, ArrayList<Person>>、ArrayList< HashMap<String, String>>

Map集合嵌套：HashMap<String, HashMap<String,String>>、HashMap<String, HashMap<Person,String>>

集合继承体系的面向对象思想
接口：用来明确所有集合中该具有的功能，相当于在定义集合功能标准；

抽象类：把多个集合中功能实现方式相同的方法，抽取到抽象类实现，具体集合不再遍写，继承使用即可；

具体类：继承抽象类，实现接口，重写所有抽象方法，达到具备指定功能的集合。每个具体集合类，根据自身的数据存储结构方式，对接口中的功能方法，进行不同方式的实现。

模拟斗地主洗牌发牌
案例介绍：按照斗地主的规则，完成洗牌发牌的动作。

具体规则：

1. 组装54张扑克牌
2. 将54张牌顺序打乱
3. 三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。
4. 查看三人各自手中的牌（按照牌的大小排序）、底牌
手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3
案例需求分析

准备牌：

完成数字与纸牌的映射关系：
使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。
洗牌：通过数字完成洗牌发牌

发牌：将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。

存放的过程中要求数字大小与斗地主规则的大小对应。

将代表不同纸牌的数字分配给不同的玩家与底牌。

看牌：

通过Map集合找到对应字符展示。

通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。

实现代码步骤：

首先，要修改java文件编码，由GBK修改为UTF-8，因为默认的字符编码GBK没有我们要的梅花、方片、黑桃、红桃(♠♥♦♣)等特殊字符。


package Poker;
import java.util.ArrayList;

import java.util.Collections;
import java.util.HashMap;

/*
* 斗地主洗牌发牌排序
*/
public class Poker {
    public static void main(String[] args) {
//准备花色
        ArrayList<String> color = new ArrayList<String>();
        color.add("♠");
        color.add("♥");
        color.add("♦");
        color.add("♣");
//准备数字
        ArrayList<String> number = new ArrayList<String>();
        Collections.addAll(number,"3","4","5","6","7","8","9","10","J","Q","K","A","2");
//定义一个map集合：用来将数字与每一张牌进行对应
        HashMap<Integer, String> map = new HashMap<Integer, String>();
        int index = 0;
        for (String thisNumber : number) {
            for (String thisColor : color) {
                map.put(index++, thisColor+thisNumber);
            }
        }

//加入大小王
        map.put(index++, "小☺");
        map.put(index++, "大☻");
//一副54张的牌 ArrayList里边为0-53的数的新牌
        ArrayList<Integer> cards = new ArrayList<Integer>();
        for (int i = 0; i <= 53; i++) {
            cards.add(i);
        }
//洗牌
        Collections.shuffle(cards);
//创建三个玩家和底牌
        ArrayList<Integer> iPlayer = new ArrayList<Integer>();
        ArrayList<Integer> iPlayer2 = new ArrayList<Integer>();
        ArrayList<Integer> iPlayer3 = new ArrayList<Integer>();
        ArrayList<Integer> itCards = new ArrayList<Integer>();
//遍历这副洗好的牌，遍历过程中，将牌发到三个玩家和底牌中
        for (int i = 0; i < cards.size(); i++) {
            if(i>=51) {
                itCards.add(cards.get(i));
            } else {
                if(i%3==0) {
                    iPlayer.add(cards.get(i));
                }else if(i%3==1) {
                    iPlayer2.add(cards.get(i));
                }else {
                    iPlayer3.add(cards.get(i));
                }
            }
        }
//对每个人手中的牌排序
        Collections.sort(iPlayer);
        Collections.sort(iPlayer2);
        Collections.sort(iPlayer3);
//对应数字形式的每个人手中的牌，定义字符串形式的牌
        ArrayList<String> sPlayer = new ArrayList<String>();
        ArrayList<String> sPlayer2 = new ArrayList<String>();
        ArrayList<String> sPlayer3 = new ArrayList<String>();
        ArrayList<String> sCards = new ArrayList<String>();
        for (Integer key : iPlayer) {
            sPlayer.add(map.get(key));
        }
        for (Integer key : iPlayer2) {
            sPlayer2.add(map.get(key));
        }
        for (Integer key : iPlayer3) {
            sPlayer3.add(map.get(key));
        }
        for (Integer key : itCards) {
            sCards.add(map.get(key));
        }
//看牌
        System.out.println(sPlayer);
        System.out.println(sPlayer2);
        System.out.println(sPlayer3);
        System.out.println(sCards);
    }
}

知识点总结
Map集合:

map集合中的元素都是成对出现，成对存储的
map集合中的元素都是以一对键和值的形式组成存在的，称为键值对，理解为夫妻对
map集合中的键不能重复存储，值可以重复
map集合中的每一个键 对应着一个值
方法：

V put(K key, V value) 把指定的键与指定的值添加到Map集合中
V remove(Object key) 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值
Set<Map.Entry<K,V>> entrySet() 获取到Map集合中所有的键值对对象的集合(Set集合)
V get(Object key) 根据指定的键，在Map集合中获取对应的值
Set<K> keySet() 获取Map集合中所有的键，存储到Set集合中
Map集合遍历的两种方式

方式1：根据键找值的方式

//a, 获取到Map集合中所有的键，返回对应的Set集合
//b, 遍历键的集合，获取到每一个键
//c, 通过键，找到对应的值
//获取到Map集合中所有的键，返回对应的Set集合
Set<String> keys = map.keySet();
//遍历键的集合，获取到每一个键
for (String key : keys) {
//通过键，找到对应的值
Student s = map.get(key);
System.out.println( key + "..." + s.getName() + "..." + s.getAge() );
}

方式2：根据键值对对象找键和值的方式

//a, 获取Map集合中所有的键值对元素,返回对应的Set集合
//b, 遍历键值对元素集合，获取到每一个键值对元素对象
//c, 通过键值对元素对象，获取对应的键，和对应的值
//获取Map集合中所有的键值对元素,返回对应的Set集合
Set< Map.Entry<String, Student>> entrySet = map.entrySet();
//遍历键值对元素集合，获取到每一个键值对元素对象
for (Map.Entry<String, Student> entry : entrySet) {
//通过键值对元素对象，获取对应的键，和对应的值
//找键
String key = entry.getKey();
//找值
Student s = entry.getValue();
//打印
System.out.println( key+"..."+s.getName()+"..."+s.getAge() );
}

HashMap:

特点：

是Map集合的子集合
底层采用哈希表结构
HashMap集合中的key不能重复，通过重写hashCode() 与 equals()方法来保证键的唯一。
不能保证元素存与取的顺序完全一致
LinkedHashMap:

特点：

是HashMap集合的子集合
底层采用哈希表+链表结构
key不能重复，通过重写hashCode() 与 equals()方法来保证键的唯一。
Collections中的方法：

public static <T> void sort(List<T> list) 排序
public static void shuffle(List<?> list) 集合中的元素存储位置随机打乱
Java基础学习笔记十八 异常处理
什么是异常？Java代码在运行时期发生的问题就是异常。

在Java中，把异常信息封装成了一个类。当出现了问题时，就会创建异常类对象并抛出异常相关的信息（如异常出现的位置、原因等）。

异常的继承体系
在Java中使用Exception类来描述异常。

查看API中Exception的描述，Exception 类及其子类是 Throwable 的一种形式，它用来表示java程序中可能会产生的异常，并要求对产生的异常进行合理的异常处理。

Exception有继承关系，它的父类是Throwable。Throwable是Java 语言中所有错误或异常的超类，即祖宗类。 

另外，在异常Exception类中，有一个子类要特殊说明一下，RuntimeException子类，RuntimeException及其它的子类只能在Java程序运行过程中出现。

我们再来观察Throwable类，能够发现与异常Exception平级的有一个Error，它是Throwable的子类，它用来表示java程序中可能会产生的严重错误。解决办法只有一个，修改代码避免Error错误的产生。

   

 



异常继承体系总结：

Throwable: 它是所有错误与异常的超类（祖宗类）
Error 错误
Exception 编译期异常,进行编译JAVA程序时出现的问题
RuntimeException 运行期异常, JAVA程序运行过程中出现的问题
异常与错误的区别

异常：指程序在编译、运行期间发生了某种异常(XxxException)，我们可以对异常进行具体的处理。若不处理异常，程序将会结束运行。

异常的产生演示如下：


  public static void main(String[] args) {
        int[] arr = new int[3];
        System.out.println(arr[0]);
        System.out.println(arr[3]);
// 该句运行时发生了数组索引越界异常ArrayIndexOutOfBoundsException，由于没有处理异常，导致程序无法继续执行，程序结束。
        System.out.println("over"); // 由于上面代码发生了异常，此句代码不会执行
    }

错误：指程序在运行期间发生了某种错误(XxxError)，Error错误通常没有具体的处理方式，程序将会结束运行。Error错误的发生往往都是系统级别的问题，都是jvm所在系统发生的，并反馈给jvm的。我们无法针对处理，只能修正代码。

错误的产生演示如下：

 

 public static void main(String[] args) {
        int[] arr = new int[1024*1024*100];
//该句运行时发生了内存溢出错误OutOfMemoryError，开辟了过大的数组空间，导致JVM在分配数组空间时超出了JVM内存空间，直接发生错误。
    }
异常的产生过程解析

先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。

工具类


class ArrayTools{
//对给定的数组通过给定的角标获取元素。
    public static int getElement(int[] arr,int index) {
        int element = arr[index];
        return element;
    }
}

测试类


class ExceptionDemo2 {
    public static void main(String[] args) {
        int[] arr = {34,12,67};
        int num = ArrayTools.getElement(arr,4)
        System.out.println("num="+num);
        System.out.println("over");
    }
}

上述程序执行过程图解：



抛出异常throw
在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。

在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？

1、创建一个异常对象。封装一些提示信息(信息可以自己编写)。

2、需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象；throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。

使用格式： throw new 异常类名(参数); 

例如：

throw new NullPointerException("要访问的arr数组不存在");
throw new ArrayIndexOutOfBoundsException("该索引在数组中不存在，已超出范围");
下面是异常类ArrayIndexOutOfBoundsException与NullPointerException的构造方法



学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。

编写工具类，提供获取数组指定索引处的元素值


class ArrayTools{
//通过给定的数组，返回给定的索引对应的元素值。
    public static int getElement(int[] arr,int index) {
/*
若程序出了异常，JVM它会打包异常对象并抛出。但是它所提供的信息不够给力。想要更清晰，需要自己抛出异常信息。
下面判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。
*/
        if(arr==null){
            throw new NullPointerException("arr指向的数组不存在");
        }
        if(index<0 || index>=arr.length){
            throw new ArrayIndexOutOfBoundsException("错误的角标，"+index+"索引在数组中不存在");
        }
        int element = arr[index];
        return element;
    }
}

测试类 


class ExceptionDemo3 {
    public static void main(String[] args) {
        int[] arr = {34,12,67}; //创建数组
        int num = ArrayTools.getElement(null,2);// 调用方法，获取数组中指定索引处元素
//int num = ArrayTools.getElement(arr,5);// 调用方法，获取数组中指定索引处元素
        System.out.println("num="+num);//打印获取到的元素值
    }
}

 声明异常throws
声明：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。

声明异常格式： 修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2… { } 

声明异常的代码演示：


class Demo{
/*
如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明。
*/
    public void show(int x)throws Exception {
        if(x>0){
            throw new Exception();
        } else {
            System.out.println("show run");
        }
    }
}

throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。

多个异常的情况，例如:


public static int getElement(int[] arr,int index) throws NullPointerException, ArrayIndexOutOfBoundsException {
        if(arr==null){
            throw new NullPointerException("arr指向的数组不存在");
        }
        if(index<0 || index>=arr.length){
            throw new ArrayIndexOutOfBoundsException("错误的角标，"+index+"索引在数组中不存在");
        }
        int element = arr[index];
        return element;
    }

捕获异常try…catch…finally
捕获：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理

捕获异常格式：


try {
　　//需要被检测的语句。
}
catch(异常类 变量) { //参数。
　　//异常的处理语句。
}
finally {
　　//一定会被执行的语句。
}

try：该代码块中编写可能产生异常的代码。

catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。

finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。

演示如下：


class ExceptionDemo{
    public static void main(String[] args){ //throws ArrayIndexOutOfBoundsException
        try{
            int[] arr = new int[3];
            System.out.println( arr[5] );// 会抛出ArrayIndexOutOfBoundsException
            //当产生异常时，必须有处理方式。要么捕获，要么声明。
        }
        catch (ArrayIndexOutOfBoundsException e) { //括号中需要定义什么呢？try中抛出的是什么异常，在括号中就定义什么异常类型。
            System.out.println("异常发生了");
        } finally {
            arr = null; //把数组指向null，通过垃圾回收器，进行内存垃圾的清除
        }
        System.out.println("程序运行结果");
    }
}

try…catch…finally异常处理的组合方式
try catch finally组合：检测异常，并传递给catch处理，并在finally中进行资源释放。

try catch组合 : 对代码进行异常检测，并对检测的异常传递给catch处理。对异常进行捕获处理。


 void show(){ //不用throws
        try{
            throw new Exception();//产生异常，直接捕获处理
        }catch(Exception e){
        //处理方式
        }
    }

一个try 多个catch组合 : 对代码进行异常检测，并对检测的异常传递给catch处理。对每种异常信息进行不同的捕获处理。


 void show(){ //不用throws
        try{
            throw new Exception();//产生异常，直接捕获处理
        }catch(XxxException e){
    　　　　//处理方式
        }catch(YyyException e){
    　　　　//处理方式
        }catch(ZzzException e){
    　　　　//处理方式
        }
    }

注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。

 try finally 组合: 对代码进行异常检测，检测到异常后因为没有catch，所以一样会被默认jvm抛出。异常是没有捕获处理的。但是功能所开启资源需要进行关闭，所有finally。只为关闭资源。


void show(){//需要throws
        try{
            throw new Exception();
        }finally {
        //释放资源
        }
    }

运行时期异常
RuntimeException和他的所有子类异常,都属于运行时期异常。NullPointerException,ArrayIndexOutOfBoundsException等都属于运行时期异常.

运行时期异常的特点
方法中抛出运行时期异常,方法定义中无需throws声明,调用者也无需处理此异常

运行时期异常一旦发生,需要程序人员修改源代码.


class ExceptionDemo{
    public static void main(String[] args){
         method();
    }

    public static void method(){
        throw new RuntimeException();
    }
}

异常在方法重写中细节
1、子类覆盖父类方法时，如果父类的方法声明异常，子类只能声明父类异常或者该异常的子类，或者不声明。

例如：

class Fu {
    public void method () throws RuntimeException {
    }
}
class Zi extends Fu {
    public void method() throws RuntimeException { }  //抛出父类一样的异常
    //public void method() throws NullPointerException{ } //抛出父类子异常
}
2、当父类方法声明多个异常时，子类覆盖时只能声明多个异常的子集。

例如：


class Fu {
    public void method () throws NullPointerException, ClassCastException{
    }
}
class Zi extends Fu {
    public void method()throws NullPointerException, ClassCastException { }   
    public void method() throws NullPointerException{ } //抛出父类异常中的一部分
    public void method() throws ClassCastException { } //抛出父类异常中的一部分
}

3、当被覆盖的方法没有异常声明时，子类覆盖是无法声明异常的。

例如：


class Fu {
    public void method (){
    }
}

class Zi extends Fu {
    public void method() throws Exception { }//错误的方式
}

举例：父类中会存在下列这种情况，接口也有这种情况

问题：接口中没有声明异常，而实现的子类覆盖方法时发生了异常，怎么办？

答：无法进行throws声明，只能catch的捕获。万一问题处理不了呢？catch中继续throw抛出，但是只能将异常转换成RuntimeException子类抛出。


interface Inter {
    public abstract void method();
}

class Zi implements Inter {
    public void method(){ //无法声明 throws Exception
        int[] arr = null;
        if (arr == null) {
　　　　　　　　//只能捕获处理
            try{
                throw new Exception(“哥们，你定义的数组arr是空的!”);
            } catch(Exception e){
                System.out.println(“父方法中没有异常抛出，子类中不能抛出Exception异常”);
                //我们把异常对象e，采用RuntimeException异常方式抛出
                throw new RuntimeException(e);
            }
        }
    }
}

异常中常用方法
在Throwable类中为我们提供了很多操作异常对象的方法，常用的如下： 

getMessage方法：返回该异常的详细信息字符串，即异常提示信息
toString方法：返回该异常的名称与详细信息字符串
printStackTrace：在控制台输出该异常的名称与详细信息字符串、异常出现的代码位置
异常的常用方法代码演示：


 try {
        Person p= null;
        if (p==null) {
            throw new NullPointerException(“出现空指针异常了，请检查对象是否为null”);
        }
    } catch (NullPointerException e) {
        String message = e.getMesage();
        System.out.println(message );
        String result = e.toString();
        System.out.println(result);
        e.printStackTrace();
    }

自定义异常
在上述代码中，发现这些异常都是JDK内部定义好的，并且这些异常不好找。书写时也很不方便，那么能不能自己定义异常呢？

之前的几个异常都是java通过类进行的描述。并将问题封装成对象，异常就是将问题封装成了对象。这些异常不好认，书写也很不方便，能不能定义一个符合我的程序要求的异常名称。既然JDK中是使用类在描述异常信息，那么我们也可以模拟Java的这种机制，我们自己定义异常的信息，异常的名字，让异常更符合自己程序的阅读。准确对自己所需要的异常进行类的描述。

自定义异常类的定义
通过阅读异常源代码：发现java中所有的异常类，都是继承Throwable，或者继承Throwable的子类。这样该异常才可以被throw抛出。说明这个异常体系具备一个特有的特性：可抛性：即可以被throw关键字操作。

并且查阅异常子类源码，发现每个异常中都调用了父类的构造方法，把异常描述信息传递给了父类，让父类帮我们进行异常信息的封装。

例如NullPointerException异常类源代码：


public class NullPointerException extends RuntimeException {
    public NullPointerException() {
        super();//调用父类构造方法
    }

    public NullPointerException(String s) {
        super(s);//调用父类具有异常信息的构造方法
    }

}

现在，我们来定义个自己的异常，即自定义异常。

格式：


Class 异常名 extends Exception{ //或继承RuntimeException
    public 异常名(){
    }

    public 异常名(String s){
   　　 super(s);
    }
}

自定义异常继承Exception演示


class MyException extends Exception{
/*
为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。
*/
public MyException(){
    super();
}
public MyException(String message) {
    super(message);// 如果自定义异常需要异常信息，可以通过调用父类的带有字符串参数的构造函数即可。

    }
}

自定义异常继承RuntimeException演示


class MyException extends RuntimeException{
/*
为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。
*/
    MyException(){
        super();
    }
    MyException(String message) {
        super(message);// 如果自定义异常需要异常信息，可以通过调用父类的带有字符串参数的构造函数即可。
    }
}

自定义异常的练习

定义Person类，包含name与age两个成员变量。在Person类的有参数构造方法中，进行年龄范围的判断，若年龄为负数或大于200岁，则抛出NoAgeException异常，异常提示信息“年龄数值非法”。

要求：在测试类中，调用有参数构造方法，完成Person对象创建，并进行异常的处理。

自定义异常类


class NoAgeException extends Exception{
    NoAgeException() {
        super();
    }

    NoAgeException(String message) {
        super(message);
    }
}

Person类


class Person{
    private String name;
    private int age;
    Person(String name,int age) throws NoAgeException {
//加入逻辑判断。
        if(age<0 || age>200) {
            throw new NoAgeException(age+",年龄数值非法");
        }
        this.name = name;
        this.age = age;
    }
//定义Person对象对应的字符串表现形式。覆盖Object中的toString方法。
    public String toString() {
        return "Person[name="+name+",age="+age+"]";
    }
}

测试类


class ExceptionDemo{
    public static void main(String[] args) {
        try {
            Person p = new Person("xiaoming",20);
            System.out.println(p);
        }
        catch (NoAgeException ex){
            System.out.println("年龄异常啦");
        }
        System.out.println("over");
    }
}

总结一下，构造函数到底抛出这个NoAgeException是继承Exception呢？还是继承RuntimeException呢？

继承Exception，必须要throws声明，一声明就告知调用者进行捕获，一旦问题处理了调用者的程序会继续执行。

继承RuntimeExcpetion,不需要throws声明的，这时调用是不需要编写捕获代码的，因为调用根本就不知道有问题。一旦发生NoAgeException，调用者程序会停掉，并有jvm将信息显示到屏幕，让调用者看到问题，修正代码。

总结
异常：就是程序中出现的不正常的现象(错误与异常)

异常的继承体系
Throwable: 它是所有错误与异常的超类（祖宗类）
|- Error 错误，修改java源代码
|- Exception 编译期异常, javac.exe进行编译的时候报错
|- RuntimeException 运行期异常, java出现运行过程中出现的问题
异常处理的两种方式
1、出现问题，自己解决 try…catch…finally


try{

    可能出现异常的代码

} catch(异常类名  对象名){

    异常处理代码

} finally {

    异常操作中一定要执行的代码

}

2、出现问题，别人解决 throws

格式：修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2,...{}

比如：public void method() throws Exception{} 

异常分类
异常的根类是Throwable，其下有两个子类：Error与Exception，平常所说的异常指Exception；严重错误Error，无法通过处理的错误。

编译时异常Exception，编译时无法编译通过。如日期格式化异常
运行时异常RuntimeException，是Exception的子类，运行时可能会报错，可以不处理。如空指针异常
异常基本操作

创建异常对象
抛出异常
处理异常：
捕获处理，将异常获取，使用try/catch做分支处理 
声明抛出处理，出现异常后不处理，声明抛出给调用者处理。 方法声明上加throws  异常类名
注意：异常的处理，指处理异常的一种可能性，即有了异常处理的代码，不一定会产生异常。如果没有产生异常，则代码正常执行，如果产生了异常，则中断当前执行代码，执行异常处理代码。

多异常处理
捕获处理

多个异常可以分别处理
多个异常一次捕获多次处理
多个异常一次捕获，采用同一种方式处理
声明抛出异常：声明上使用,一次声明多个异常

运行时异常被抛出可以不处理。即不捕获也不声明抛出

如果父类抛出了多个异常,子类覆盖父类方法时,只能抛出相同的异常或者是他的子集

父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出

当多异常处理时，捕获处理，前边的类不能是后边类的父类

自定义异常
如果Java没有提供你需要的异常，则可以自定义异常类。

定义方法：编译时异常继承Exception，运行时异常继承RuntimeException。

throw 和throws 的区别是什么
throw
定义在方法中，后边跟的是异常对象
同时只能抛出一个异常对象

throws
定义在方法的声明上，后边跟的是异常的类型
后边同时可以跟多个数据类型

finally 返回路径
finally ：在正常情况下，肯定执行的代码，在try中return，在finally中修改。每次碰到return就会在返回路径中临时存储这个被返回的值，无论方法内有任何的改变，返回路径中的这个值一致不变。


public class Demo {
    public static void main(String[] args) {
        Test t = new Test();
        int method = t.method();
        System.out.println(method);
    }
}

class Test {
    public int method() {
        int i = 0;
        try {
            System.out.println(1 / 0);
            return i;
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            i = 200;
            System.out.println("我一定会运行");
        }
        return i;
    }
    //返回路径：每次碰到return就会在返回路径中临时存储这个被返回的值，无论方法内有任何的改变，返回路径中的这个值一致不变。
}

//我一定会运行
//200
//java.lang.ArithmeticException: / by zero
//at inter.Test.method(Demo.java:15)
//at inter.Demo.main(Demo.java:6)
//
//Process finished with exit code 0

Java基础学习笔记十九 File
IO概述
回想之前写过的程序，数据都是在内存中，一旦程序运行结束，这些数据都没有了，等下次再想使用这些数据，可是已经没有了。那怎么办呢？能不能把运算完的数据都保存下来，下次程序启动的时候，再把这些数据读出来继续使用呢？其实要把数据持久化存储，就需要把内存中的数据存储到内存以外的其他持久化设备(硬盘、光盘、U盘等)上。

当需要把内存中的数据存储到持久化设备上这个动作称为输出（写）Output操作。当把持久设备上的数据读取到内存中的这个动作称为输入（读）Input操作。因此我们把这种输入和输出动作称为IO操作。

File类
File类是File文件和目录路径名的抽象表示形式。即，Java中把文件或者目录（文件夹）都封装成File对象。也就是说如果我们要去操作硬盘上的文件，或者文件夹只要找到File这个类即可。那么我们就要研究研究File这个类中都有那些功能可以操作文件或者文件夹呢？

File类的构造函数
通过构造方法创建File对象，我们进行演示：


package inter;
import java.io.File;
public class Demo {
    public static void main(String[] args) {
        //File构造函数演示
        String pathName = "e:\\java_code\\hello.java";
        File f1 = new File(pathName);//将Test22文件封装成File对象。注意；可以封装不存在文件或者文件夹，变成对象。
        System.out.println(f1);
        File f2 = new File("e:\\java_code","hello.java");
        System.out.println(f2);
        //将parent封装成file对象。
        File dir = new File("e:\\java_code");
        File f3 = new File(dir,"hello.java");
        System.out.println(f3);
    }
}
//e:\java_code\hello.java
// e:\java_code\hello.java
// e:\java_code\hello.java

File类的获取
创建完了File对象之后，那么File类中都有如下常用方法，可以获取文件相关信息

方法演示如下：


package inter;
import java.io.File;
public class Demo {
    public static void main(String[] args) {
        //创建文件对象
        File file = new File("Demo.java");
        //获取文件的绝对路径，即全路径
        String absPath = file.getAbsolutePath();
        //File中封装的路径是什么获取到的就是什么。
        String path = file.getPath();
        //获取文件名称
        String filename = file.getName();
        //获取文件大小
        long size = file.length();
        System.out.println("absPath="+absPath);
        System.out.println("path="+path);
        System.out.println("filename="+filename);
        System.out.println("size="+size);
    }

}
//absPath=F:\编程语言\Java\Project\Projects\typeInfo\Demo.java
//path=Demo.java
//filename=Demo.java
//size=0

文件和文件夹的创建删除等
经常上面介绍，我们知道可以通过File获取到文件名称，文件路径(目录)等信息。接下来演示使用File类创建、删除文件等操作。代码演示：


package inter;

import java.io.File;
import java.io.IOException;

public class Demo {
    public static void main(String[] args) throws IOException {
// 对文件或者文件加进行操作。
        File file = new File("f:\\file.txt");
// 创建文件，如果文件不存在，创建 true 如果文件存在，则不创建 false。 如果路径错误，IOException。
        boolean b1 = file.createNewFile();
        System.out.println("b1=" + b1);
//-----------删除文件操作-------注意：不去回收站。慎用------
        boolean b2 = file.delete();
        System.out.println("b2=" + b2);
//-----------需要判断文件是否存在------------
        boolean b3 = file.exists();
        System.out.println("b3=" + b3);
//-----------对目录操作 创建，删除，判断------------
        File dir = new File("f:\\abc");
//mkdir()创建单个目录。
        boolean b4 = dir.mkdir();
        System.out.println("b4=" + b4);
        File dir1 = new File("f:\\abcd\\ef\\gh");
//dir.mkdirs();创建多级目录
        boolean b5 = dir1.mkdirs();
        System.out.println("b5=" + b5);

//删除目录时，如果目录中有内容，无法直接删除。
        boolean b6 = dir.delete();
//只有将目录中的内容都删除后，保证该目录为空。这时这个目录才可以删除。
        System.out.println("b6=" + b6);
//-----------判断文件，目录------------
        File f = new File("f:\\javahaha");// 要判断是否是文件还是目录，必须先判断存在。
// f.mkdir();//f.createNewFile();
        System.out.println(f.isFile());
        System.out.println(f.isDirectory());
    }
}

//b1=true
//b2=true
//b3=false
//b4=true
//b5=true
//b6=true
//false
//false

listFiles()方法介绍
文件都存放在目录（文件夹）中，那么如何获取一个目录中的所有文件或者目录中的文件夹呢？

方法演示如下：


package inter;
import java.io.File;
public class Demo {
    public static void main(String[] args) {
        File dir = new File("F:\\源码学习");
//获取的是目录下的当前的文件以及文件夹的名称。
        String[] names = dir.list();
        for(String name : names){
            System.out.println(name);
        }
//获取目录下当前文件以及文件对象，只要拿到了文件对象，那么就可以获取其中想要的信息
        File[] files = dir.listFiles();
        for(File file : files){
            System.out.println(file);
        }
    }
}
//ace-master.zip
//nfine-NFine-master
//nfine-NFine-master.zip
//SugarSite-master
//SugarSite-master.zip
//TaskManager-master
//TaskManager-master.zip
//WebDemo.rar
//websocket聊天室
//定时框架demo源码
//行动日志
//路过秋天的开源项目
//F:\源码学习\ace-master.zip
//F:\源码学习\nfine-NFine-master
//F:\源码学习\nfine-NFine-master.zip
//F:\源码学习\SugarSite-master
//F:\源码学习\SugarSite-master.zip
//F:\源码学习\TaskManager-master
//F:\源码学习\TaskManager-master.zip
//F:\源码学习\WebDemo.rar
//F:\源码学习\websocket聊天室
//F:\源码学习\定时框架demo源码
//F:\源码学习\行动日志
//F:\源码学习\路过秋天的开源项目

注意：在获取指定目录下的文件或者文件夹时必须满足下面两个条件

1、指定的目录必须是存在的，
2、指定的必须是目录。否则容易引发返回数组为null，出现NullPointerException
文件过滤器
通过listFiles()方法，我们可以获取到一个目录下的所有文件和文件夹，但能不能对其进行过滤呢？比如我们只想要一个目录下的指定扩展名的文件，或者包含某些关键字的文件夹呢？我们是可以先把一个目录下的所有文件和文件夹获取到，并遍历当前获取到所有内容，遍历过程中在进行筛选，但是这个动作有点麻烦，Java给我们提供相应的功能来解决这个问题。查阅File类的API，在查阅时发现File类中重载的listFiles方法，并且接受指定的过滤器。

测试类


import java.io.File;
import java.io.FilenameFilter;

public class Test {
    public static void main(String[] args) {
//获取扩展名为.java所有文件
//创建File对象
        File file = new File("F:\\源码学习");
//获取指定扩展名的文件,由于要对所有文件进行扩展名筛选，因此调用方法需要传递过滤器
        File[] files = file.listFiles(new MyFileFilter());
//遍历获取到的所有符合条件的文件
        for (File f : files) {
            System.out.println(f);
        }
    }
}
class MyFileFilter implements FilenameFilter {
    public boolean accept(File dir, String name) {
        return name.endsWith(".zip");
    }
}
//F:\源码学习\ace-master.zip
//F:\源码学习\nfine-NFine-master.zip
//F:\源码学习\SugarSite-master.zip
//F:\源码学习\TaskManager-master.zip

自定类继承FilenameFilter过滤器接口
在查阅API时，我们发现，在listFiles(FileFilter filter) 也可以接受一个FileFilter过滤器，它和我们讲的FilenameFilter有啥区别呢？

FilenameFilter过滤器中的accept方法接受两个参数，一个当前文件或文件夹所在的路径，一个是当前文件或文件夹对象的名称。
FileFilter 过滤器中的accept方法接受一个参数，这个参数就当前文件或文件夹对象
当我们需要过滤文件名称时就可以使用FilenameFilter这个过滤器，当我们想对当前文件或文件夹进行过滤，就可以使用FileFilter ，比如需要当前目录下的所有文件夹，就可以使用FileFilter 过滤器。

测试类


import java.io.File;
import java.io.FileFilter;

public class Test {
    public static void main(String[] args) {
//获取扩展名为.java所有文件
//创建File对象
        File file = new File("F:\\源码学习");
//获取指定目录下的文件夹
        File[] files = file.listFiles(new FileFileterByDir());
//遍历获取到的所有符合条件的文件
        for (File f : files) {
           System.out.println(f);
        }
    }
}
//自定义类继承FileFilter过滤器接口
//文件过滤器
class FileFileterByDir implements FileFilter {
    public boolean accept(File pathname) {
        return pathname.isDirectory();
    }
}

//F:\源码学习\nfine-NFine-master
//F:\源码学习\SugarSite-master
//F:\源码学习\TaskManager-master
//F:\源码学习\websocket聊天室
//F:\源码学习\定时框架demo源码
//F:\源码学习\行动日志
//F:\源码学习\路过秋天的开源项目

递归
递归，指在当前方法内调用自己的这种现象。递归分为两种，直接递归和间接递归。直接递归称为方法自身调用自己。间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。

递归的代码演示，计算1-n之间的和，使用递归完成


public class DiGuiDemo {
    public static void main(String[] args) {
//计算1~num的和，使用递归完成
        int n = 5;
        int sum = getSum(n);
        System.out.println(sum);
    }
    public static int getSum(int n) {
        if(n == 1){
            return 1;
        }
        return n + getSum(n-1);
    }
}

注意：递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。



递归打印所有子目录中的文件路径
编写一个方法用来打印指定目录中的文件路径，并进行方法的调用。要求：若指定的目录有子目录，那么把子目录中的文件路径也打印出来。

代码演示


import java.io.File;

public class Test {
    public static void main(String[] args) {
        File file = new File("F:\\源码学习\\nfine-NFine-master\\NFine");
        getFileAll(file);
    }
//获取指定目录以及子目录中的所有的文件
    public static void getFileAll(File file) {
        File[] files = file.listFiles();
//遍历当前目录下的所有文件和文件夹
        for (File f : files) {
//判断当前遍历到的是否为目录
            if(f.isDirectory()){
//是目录，继续获取这个目录下的所有文件和文件夹
                getFileAll(f);
            }else{
//不是目录，说明当前f就是文件，那么就打印出来
                System.out.println(f);
            }
        }
    }
}

字符编码表
我们知道计算机底层数据存储的都是二进制数据，而我们生活中的各种各样的数据，如何才能和计算机中存储的二进制数据对应起来呢？这时老美他们就把每一个字符和一个整数对应起来，就形成了一张编码表，老美他们的编码表就是ASCII表。其中就是各种英文字符对应的编码。

编码表：其实就是生活中字符和计算机二进制的对应关系表。

1、ascii： 一个字节中的7位就可以表示。对应的字节都是正数。0-xxxxxxx

2、iso-8859-1:拉丁码表 latin，用了一个字节用的8位。1-xxxxxxx 负数。

3、GB2312:简体中文码表。包含6000-7000中文和符号。用两个字节表示。两个字节第一个字节是负数,第二个字节可能是正数

GBK:目前最常用的中文码表，2万的中文和符号。用两个字节表示，其中的一部分文字，第一个字节开头是1，第二字节开头是0
GB18030：最新的中文码表，目前还没有正式使用。
4、unicode：国际标准码表:无论是什么文字，都用两个字节存储。

Java中的char类型用的就是这个码表。char c = 'a';占两个字节。
Java中的字符串是按照系统默认码表来解析的。简体中文版 字符串默认的码表是GBK。
5、UTF-8:基于unicode，一个字节就可以存储数据，不要用两个字节存储，而且这个码表更加的标准化，在每一个字节头加入了编码信息(后期到api中查找)。

能识别中文的码表：GBK、UTF-8；正因为识别中文码表不唯一，涉及到了编码解码问题。对于我们开发而言；常见的编码 GBK UTF-8 ISO-8859-1

文字--->(数字) ：编码。 “abc”.getBytes() byte[]

(数字)--->文字 : 解码。 byte[] b={97,98,99} ；new String(b)
java基础 IO流
java中流的体系结构
IO流主要是用来处理设备之间的数据传输。

流按操作的数据可分为字符流和字节流。字节流用于处理二进制文件，比如音频、视频等；字符流用于处理带有中文字符的文件，比如文本文件。

流按照数据的流向可分为输入流和输出流。输入输出是相对于内存来说的，输入就是把某个地方（比如磁盘）的数据读到内存中，输出就是把数据从内存中写到某个地方（比如磁盘）。
java中流的体系结构如下，由于实现类实在太多，标记颜色的为常用的类。

 

字节流
FileOutputStream 
我们常用来向文件中写入数据的流是FileOutputStream ，主要用于写入诸如图像数据之类的原始字节的流。

构造函数如下：

FileOutputStream(File file) 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。
FileOutputStream(File file, boolean append)  创建一个向指定 File 对象表示的文件中写入数据的文件输出流。
FileOutputStream(FileDescriptor fdObj)  创建一个向指定文件描述符处写入数据的输出文件流，该文件描述符表示一个到文件系统中的某个实际文件的现有连接。
FileOutputStream(String name)  创建一个向具有指定名称的文件中写入数据的输出文件流。
FileOutputStream(String name, boolean append)  创建一个向具有指定 name 的文件中写入数据的输出文件流。
写入的方法有3个，具体如下：

 void    write(byte[] b)  将 b.length 个字节从指定 byte 数组写入此文件输出流中。
 void    write(byte[] b, int off, int len)  将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流。
 void    write(int b) 将指定字节写入此文件输出流。
举个例子：

 String filePath =  "D:\\Learning\\doc\\test.txt";
// 向test.txt文件中写入数据
 FileOutputStream fos=new FileOutputStream(filePath);
 fos.write("学习IO流".getBytes());
 fos.close();
FileInputStream 
和FileOutputStream对应的是FileInputStream ，用于读取诸如图像数据之类的原始字节流，文件不存在会创建。

构造函数如下：

FileInputStream(File file)  通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的 File 对象 file 指定。
FileInputStream(FileDescriptor fdObj)  通过使用文件描述符 fdObj 创建一个 FileInputStream，该文件描述符表示到文件系统中某个实际文件的现有连接。
FileInputStream(String name)  通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的路径名 name 指定。
读取的方法如下，read方法从此输入流中读取数据字节。如果没有输入可用，则此方法将阻塞。如果因为已经到达文件末尾而没有更多的数据，则返回 -1。

 int    read()  从此输入流中读取一个数据字节。
 int    read(byte[] b)  从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。
 int    read(byte[] b, int off, int len)  从此输入流中将最多 len 个字节的数据读入一个 byte 数组中。
举个例子：


String filePath =  "D:\\Learning\\doc\\test1.txt";
//读取test文件内容
FileInputStream fis=new FileInputStream(filePath);//方式一：一个字节一个字节的读取
int ch=0;
while ((ch=fis.read())!=-1) {
   System.out.print((char)ch);
}

//方式二：批量读取到缓冲区，推荐使用方式
int len=0;
byte[] buffer=new byte[1024];
while ((len=fis.read(buffer))!=-1){
    System.out.print(new String(buffer,0,len));
}

//方式三：一次性读取，不建议使用，如果文件过大，那么数组会非常大，可能内存不够，创建数组也会非常耗时
//fis.available()获取文件的字节数
byte[] buf = new byte[fis.available()];
fis.read(buf);
System.out.println(new String(buf));
fis.close();

下面代码演示了如何拷贝文件：


//需求：把vedio拷贝到vedio1
String sourceFilePath = "D:\\Learning\\doc\\vedio.avi";
String destFilePath = "D:\\Learning\\doc\\vedio1.avi";
//创建读取文件对象
FileInputStream fis=new FileInputStream(sourceFilePath);
//创建写入文件对象
FileOutputStream fos=new FileOutputStream(destFilePath);
//创建1M的缓冲区
byte[] buffer =new byte[1024*1024*1];
//每次读取的长度,可能最后一次的读取长度并没有buffer.length那么多
int len=0;
while ((len=fis.read(buffer))!=-1){
    fos.write(buffer,0,len);
}
fos.close();
fis.close();

当然，如果是很小的文件，也可以直接向下面这样，但对于大文件，禁止使用：


        //需求：把vedio拷贝到vedio1
        String sourceFilePath = "D:\\Learning\\doc\\vedio.avi";
        String destFilePath = "D:\\Learning\\doc\\vedio1.avi";
        //创建读取文件对象
        FileInputStream fis=new FileInputStream(sourceFilePath);
        //创建写入文件对象
        FileOutputStream fos=new FileOutputStream(destFilePath);
        byte[] buf = new byte[fis.available()];
        fis.read(buf);
        fos.write(buf);

        fos.close();
        fis.close();

上面我们手动创建了缓冲区用来提高字节读写效率，java也提供了同样的功能，即BufferInputStream，BufferOutputStream。

BufferedInputStream
BufferedInputStream 为另一个输入流添加一些功能，即缓冲输入以及支持 mark 和 reset 方法的能力。在创建 BufferedInputStream 时，会创建一个内部缓冲区数组。

构造函数如下：

BufferedInputStream(InputStream in) 创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。
BufferedInputStream(InputStream in, int size) 创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。
读取方法如下：

 int    read()  参见 InputStream 的 read 方法的常规协定。
 int    read(byte[] b, int off, int len)  从此字节输入流中给定偏移量处开始将各字节读取到指定的 byte 数组中。
BufferOutputStream
该类实现缓冲的输出流。通过设置这种输出流，应用程序就可以将各个字节写入底层输出流中，而不必针对每次字节写入调用底层系统。

构造方法如下：

BufferedOutputStream(OutputStream out)  创建一个新的缓冲输出流，以将数据写入指定的底层输出流。
BufferedOutputStream(OutputStream out, int size)  创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。
write方法如下：

 void    write(byte[] b, int off, int len)  将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此缓冲的输出流。
 void    write(int b)  将指定的字节写入此缓冲的输出流。
下面来看看如何使用：


        //需求：把vedio拷贝到vedio1
        String sourceFilePath = "D:\\Learning\\doc\\vedio.avi";
        String destFilePath = "D:\\Learning\\doc\\vedio1.avi";
        //创建读取文件对象
        FileInputStream fis=new FileInputStream(sourceFilePath);
        //创建写入文件对象
        FileOutputStream fos=new FileOutputStream(destFilePath);
        BufferedInputStream bis=new BufferedInputStream(fis);
        BufferedOutputStream bos=new BufferedOutputStream(fos);

        int len =0;
        while ((len=bis.read())!=-1){
            bos.write(len);
        }
        //缓冲流是在普通流的基础上多了一个缓冲区  ,   
        // 当读或写的数据达到一定量,再自动往文件里进行读写,如果没有装满缓冲区文件就已经读(写)完毕 ,   
        // 那么这个时候已经读写到缓冲区的数据需要手动使其朝目标文件进行读写.
        //所以使用缓冲流一定要调用flush方法
        bos.flush();
        bis.close();
        bos.close();

当然，也可以自己再创建一个缓冲区进一步提高效率，也可以在构造函数的第二个参数传入缓冲区大小：


import java.io.*;

class Test {
    public static void main(String[]args) throws IOException {
        //测试拷贝一个大小为200M时的性能问题
        test1();
        test2();
        test3();
    }

    public static final int BUFFER_SIZE = 1024 * 1024 * 1;

    /**
     * 方式一：不加缓冲区的情况
     *
     * @throws IOException
     */
    public static void test1() throws IOException {
        //需求：把vedio拷贝到vedio1
        String sourceFilePath = "E:\\desktop.zip";
        String destFilePath = "E:\\desktop1.zip";
        //创建读取文件对象
        FileInputStream fis = new FileInputStream(sourceFilePath);
        //创建写入文件对象
        FileOutputStream fos = new FileOutputStream(destFilePath);
        BufferedInputStream bis = new BufferedInputStream(fis);
        BufferedOutputStream bos = new BufferedOutputStream(fos);

        long start = System.currentTimeMillis();
        int len = 0;
        while ((len = bis.read()) != -1) {
            bos.write(len);
        }
        long end = System.currentTimeMillis();
        System.out.println(end - start);//21365

        bos.flush();
        bis.close();
        bos.close();
    }

    /**
     * 方式二：加缓冲区的情况
     * @throws IOException
     */
    public static void test2() throws IOException {
        //需求：把vedio拷贝到vedio1
        String sourceFilePath = "E:\\desktop.zip";
        String destFilePath = "E:\\desktop2.zip";
        //创建读取文件对象
        FileInputStream fis = new FileInputStream(sourceFilePath);
        //创建写入文件对象
        FileOutputStream fos = new FileOutputStream(destFilePath);
        BufferedInputStream bis = new BufferedInputStream(fis);
        BufferedOutputStream bos = new BufferedOutputStream(fos);

        long start = System.currentTimeMillis();
        byte[] buffer = new byte[BUFFER_SIZE];
        int len = 0;
        while ((len = bis.read(buffer)) != -1) {
            bos.write(buffer, 0, len);
        }
        long end = System.currentTimeMillis();
        System.out.println(end - start);//975
        bos.flush();
        bis.close();
        bos.close();
    }

    /**
     * 方式3：构造函数加入缓冲大小的情况
     * @throws IOException
     */
    public static void test3() throws IOException {
        // 需求：把vedio拷贝到vedio1
        String sourceFilePath = "E:\\desktop.zip";
        String destFilePath = "E:\\desktop3.zip";
        //创建读取文件对象
        FileInputStream fis = new FileInputStream(sourceFilePath);
        //创建写入文件对象
        FileOutputStream fos = new FileOutputStream(destFilePath);
        BufferedInputStream bis = new BufferedInputStream(fis, BUFFER_SIZE);
        BufferedOutputStream bos = new BufferedOutputStream(fos, BUFFER_SIZE);

        long start = System.currentTimeMillis();
        int len = 0;
        while ((len = bis.read()) != -1) {
            bos.write(len);
        }
        long end = System.currentTimeMillis();
        System.out.println(end - start);//3036
        bos.flush();
        bis.close();
        bos.close();
    }
}

由此可见，手动加缓冲区的效率最高。

上面对于IO的异常处理是直接抛出，并未处理，下面介绍一下IO流的正确异常处理方式：


   String filePath = "D:\\Learning\\doc\\test.txt";
        FileOutputStream fos= null;
        try {
            fos = new FileOutputStream(filePath);
            fos.write("123456".getBytes());
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
　　　　　　　if(fos!=null){　 
            　　try {
                　　//一定要记得关闭流，否则文件可能一直被占用而无法操作
                　　fos.close();
            　　} catch (IOException e) {
                　　e.printStackTrace();
            　　}
　　　　　　}
        }

字符流
上面介绍了字节流，如果我们写入的是中文，然后使用字节流读取出来，就会出现乱码。


        String filePath = "D:\\Learning\\doc\\test.txt";
        FileOutputStream fos= null;
        FileInputStream fis =null;
        try {
            fos = new FileOutputStream(filePath);
            fis=new FileInputStream(filePath);
            fos.write("学习IO流".getBytes());

            int ch;
            while ((ch=fis.read())!=-1){
                System.out.print((char)ch);//å­¦ä¹ IOæµ
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
　　　　　　　　　　//忘了判断null
                fis.close();
                fos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

为什么会乱码呢?因为java中的char存的是Unicode字符，占用2个字节，而中文也是2个字节，上面的代码每次去一个字节区unicode字符集中查找，肯定找到的不是对应的中文，因此乱码。下面对上面的代码改造一下，手动指定编码方式，就可以解决乱码问题。关于字符的编码问题可以参考这里。


        String filePath = "D:\\Learning\\doc\\test.txt";
        FileOutputStream fos= null;
        FileInputStream fis =null;
        try {
            fos = new FileOutputStream(filePath);
            fis=new FileInputStream(filePath);
            fos.write("学习IO流".getBytes("UTF-8"));
            byte [] buffer =new byte[1024];
            int len;
            while ((len=fis.read(buffer))!=-1){
                System.out.print(new String(buffer,0,len,"UTF-8"));
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
　　　　　　　　　　//忘了判断null
                fis.close();
                fos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

上面的代码相对比较繁琐，java给我们提供了字符流，方便对中文等字符进行处理，下面来看看常用的FileReader和FileWriter。

FileWriter
FileWriter 用于写入字符流。用来写入字符文件的便捷类。使用平台（操作系统）默认字符编码。比如Windows简体中文版操作系统使用的编码为gbk。

构造函数如下：

FileWriter(File file)  根据给定的 File 对象构造一个 FileWriter 对象。
FileWriter(File file, boolean append)  根据给定的 File 对象构造一个 FileWriter 对象。
FileWriter(FileDescriptor fd)  构造与某个文件描述符相关联的 FileWriter 对象。
FileWriter(String fileName)  根据给定的文件名构造一个 FileWriter 对象。
FileWriter(String fileName, boolean append)  根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象。
写入方法如下：

 void    write(char[] cbuf)  写入字符数组。
 void    write(int c)   写入单个字符。
 void    write(String str)  写入字符串。
 void    write(char[] cbuf, int off, int len)  写入字符数组的某一部分。
 void    write(String str, int off, int len)  写入字符串的某一部分。
举个例子：


    String filePath = "D:\\Learning\\doc\\test.txt";
        FileWriter fw= null;
        try {
            fw = new FileWriter(filePath);
            fw.write("学习IO流");
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                //字符流如果不关闭，写入不会成功，因为字符流关闭之前会先刷新一下
                //也可以手动刷新
　　　　　　　　　 //忘了判断null
                fw.flush();
                fw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

FileReader
FileReader 用于读取字符流。用来读取字符文件的便捷类。

构造方法如下：

FileReader(File file)  在给定从中读取数据的 File 的情况下创建一个新 FileReader。
FileReader(FileDescriptor fd)  在给定从中读取数据的 FileDescriptor 的情况下创建一个新 FileReader。
FileReader(String fileName)   在给定从中读取数据的文件名的情况下创建一个新 FileReader。
读取方法如下：

 int    read()  读取单个字符。
 int    read(char[] cbuf)  将字符读入数组。
 int    read(char[] cbuf, int off, int len)  将字符读入数组的某一部分。
 int    read(CharBuffer target)  试图将字符读入指定的字符缓冲区。
举个例子：


 String filePath = "D:\\Learning\\doc\\test.txt";
        FileReader fr = null;
        try {
            fr = new FileReader(filePath);
            //方式一：一次读取一个字符（2个字节）
//            int ch = 0;
//            while ((ch = fr.read()) != -1) {
　　　　　　　　　　 //此处如果不转为字符串，会查找Unicode，而字符串也是使用的平台默认编码，所以需要转成字符串才不会乱码
//                System.out.print((char) ch + "");
//            }

            //方式二：批量读取字符到缓冲区
           char[] buffer =new char[1024];
            int  len = 0;
            while ((len = fr.read(buffer)) != -1) {
                System.out.print(new String(buffer,0,len));
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (fr != null) {
                    fr.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

下面代码演示了如何复制文本文件：


 　　　　//复制文本文件
        String sourceFilePath = "D:\\Learning\\doc\\test.txt";
        String destFilePath = "D:\\Learning\\doc\\test1.txt";
        FileReader fr = null;
        FileWriter fw=null;
        try {
            fr = new FileReader(sourceFilePath);
            fw=new FileWriter(destFilePath);
           char[] buffer =new char[1024];
            int  len = 0;
            while ((len = fr.read(buffer)) != -1) {
                fw.write(buffer,0,len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (fr != null) {
                    fr.close();
                }
                if (fw != null) {
                    fw.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

上面我们手动创建了缓冲区用来提高字符读写效率，java也提供了同样的功能，即BufferReader，BufferWriter。

BufferReader
从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。

构造函数如下：

BufferedReader(Reader in)  创建一个使用默认大小输入缓冲区的缓冲字符输入流。
BufferedReader(Reader in, int sz)  创建一个使用指定大小输入缓冲区的缓冲字符输入流。
reader方法如下：

 int    read()  读取单个字符。
 int    read(char[] cbuf, int off, int len)  将字符读入数组的某一部分。
 String    readLine()  读取一个文本行。
BufferWriter
将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。可以指定缓冲区的大小，或者接受默认的大小。在大多数情况下，默认值就足够大了。

构造方法如下：

BufferedWriter(Writer out)  创建一个使用默认大小输出缓冲区的缓冲字符输出流。
BufferedWriter(Writer out, int sz)  创建一个使用给定大小输出缓冲区的新缓冲字符输出流。
writer方法如下：

 void    newLine()  写入一个行分隔符。
 void    write(char[] cbuf, int off, int len)  写入字符数组的某一部分。
 void    write(int c)  写入单个字符。
 void    write(String s, int off, int len)  写入字符串的某一部分。
接下来看看如何使用：


　　　　 //复制文本文件
        String sourceFilePath = "D:\\Learning\\doc\\git简单操作.txt";
        String destFilePath = "D:\\Learning\\doc\\test1.txt";
        BufferedReader br = null;
        BufferedWriter bw = null;
        try {
            FileReader fr = new FileReader(sourceFilePath);
            FileWriter fw = new FileWriter(destFilePath);
            br = new BufferedReader(fr);
            bw = new BufferedWriter(fw);
            String line = null;//一行一行的读取和写入
            while ((line = br.readLine()) != null) {
                bw.write(line);
                bw.newLine();
            }
            //使用缓冲对象一定要flush
            bw.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (br != null) {
                    br.close();
                }
                if (bw != null) {
                    bw.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

LineNumberReader
跟踪行号的缓冲字符输入流。此类定义了方法 setLineNumber(int) 和 getLineNumber()，它们可分别用于设置和获取当前行号。

默认情况下，行编号从 0 开始。该行号随数据读取在每个行结束符处递增，并且可以通过调用 setLineNumber(int) 更改行号。

但要注意的是，setLineNumber(int) 不会实际更改流中的当前位置；它只更改将由 getLineNumber() 返回的值。

下面看看简单的使用方式：


　　　　 String sourceFilePath = "D:\\Learning\\doc\\git简单操作.txt";
        FileReader fr = null;
        LineNumberReader lnr =null;
        try {
            fr = new FileReader(sourceFilePath);
            lnr = new LineNumberReader(fr);
            String line = null;
            lnr.setLineNumber(100);//设置起始行号为100
            while((line=lnr.readLine())!=null){
                System.out.println(lnr.getLineNumber()+":"+line);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(lnr!=null){
                try {
                    lnr.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

转换流
 InputStreamReader
字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。

为了达到最高效率，可要考虑在 BufferedReader 内包装 InputStreamReader。例如：

BufferedReader in= new BufferedReader(new InputStreamReader(System.in));
构造方法如下：

InputStreamReader(InputStream in)  创建一个使用默认字符集的 InputStreamReader。
InputStreamReader(InputStream in, Charset cs)  创建使用给定字符集的 InputStreamReader。
InputStreamReader(InputStream in, CharsetDecoder dec)  创建使用给定字符集解码器的 InputStreamReader。
InputStreamReader(InputStream in, String charsetName)  创建使用指定字符集的 InputStreamReader。
读取方法如下：

int    read() 读取单个字符。
int    read(char[] cbuf, int offset, int length)  将字符读入数组中的某一部分。
举个例子，比如获取键盘输入的内容，并打印在控制台上，要求不能用Scanner对象：


        //需求：把键盘输入的内容打印在控制台
        InputStreamReader isr = new InputStreamReader(System.in);
        //方式一：直接读取
//        int ch = 0;
//        while ((ch=isr.read())!=-1){
//            System.out.print((char) ch+"");
//        }

        //方式二：读到缓冲区
        int len = 0;
        char [] buffer =new char[1024];
        while ((len=isr.read(buffer))!=-1){
            System.out.print(new String(buffer,0,len));
        }

        //方式三：使用缓冲流提供的便捷方法
        BufferedReader br =new BufferedReader(isr) ;
        String line=null;
        while((line=br.readLine())!=null){
            System.out.print(line);
        }
    }

OutputStreamWriter
是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。
为了获得最高效率，可考虑将 OutputStreamWriter 包装到 BufferedWriter 中，以避免频繁调用转换器。例如：

Writer out = new BufferedWriter(new OutputStreamWriter(System.out));
构造方法如下：

OutputStreamWriter(OutputStream out)  创建使用默认字符编码的 OutputStreamWriter。
OutputStreamWriter(OutputStream out, Charset cs)  创建使用给定字符集的 OutputStreamWriter。
OutputStreamWriter(OutputStream out, CharsetEncoder enc)  创建使用给定字符集编码器的 OutputStreamWriter。
OutputStreamWriter(OutputStream out, String charsetName)  创建使用指定字符集的 OutputStreamWriter。
写入方法如下：

 void    write(char[] cbuf, int off, int len)  写入字符数组的某一部分。
 void    write(int c)  写入单个字符。
 void    write(String str, int off, int len)  写入字符串的某一部分。
举个例子，比如把文本文件的内容打印在控制台上，要求不能用print方法：


        OutputStreamWriter osw=new OutputStreamWriter(System.out);
        String line="学习IO流";
        //方式一：直接写入
//        osw.write(line);
//        osw.close();
        //方式二：使用缓冲流高效写入
        BufferedWriter bw=new BufferedWriter(osw);
        bw.write(line);
        bw.close();

再来个例子，将键盘录入的数据写入到一个文件中：


 　　　　String filePath="E:\\test.txt";
        //需求：将键盘录入的数据写入到一个文件中。
        BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(filePath)));
        String line = null;
        while((line=bufr.readLine())!=null){
            if(":wq".equals(line))
                break;
            bufw.write(line.toUpperCase());
            bufw.newLine();
            bufw.flush();
        }

上面的例子举得有点牵强，正在的用处在于上面这两个对象可以手动指定编码，比如读取文本文件，必须指定utf-8来编码。用FileReader是做不到的。

InputStreamReader isr = new InputStreamReader(new FileInputStream("E:\\test.txt"),"utf-8");
Java基础学习笔记二十 IO流
Properties类
Properties类表示了一个持久的属性集。Properties可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。

特点：

Hashtable的子类，map集合中的方法都可以用。
该集合没有泛型。键值都是字符串。
它是一个可以持久化的属性集。键值可以存储到集合中，也可以存储到持久化的设备(硬盘、U盘、光盘)上。键值的来源也可以是持久化的设备。
有和流技术相结合的方法。
load(InputStream)  把指定流所对应的文件中的数据，读取出来，保存到Propertie集合中
load(Reader)  
store(OutputStream,commonts)把集合中的数据，保存到指定的流所对应的文件中，参数commonts代表对描述信息
stroe(Writer,comments);
代码演示：


package io;

import java.util.Properties;
import java.util.Set;
/*
 *
 * Properties集合，它是唯一一个能与IO流交互的集合
 *
 * 需求：向Properties集合中添加元素，并遍历
 *
 * 方法：
 * public Object setProperty(String key, String value)调用 Hashtable 的方法 put。
 * public Set<String> stringPropertyNames()返回此属性列表中的键集，
 * public String getProperty(String key)用指定的键在此属性列表中搜索属性
 */
public class PropertiesDemo01 {
    public static void main(String[] args) {
        //创建集合对象
        Properties prop = new Properties();
        //添加元素到集合
        //prop.put(key, value);
        prop.setProperty("周迅", "张学友");
        prop.setProperty("李小璐", "贾乃亮");
        prop.setProperty("杨幂", "刘恺威");

        //System.out.println(prop);//测试的使用
        //遍历集合
        Set<String> keys = prop.stringPropertyNames();
        for (String key : keys) {
            //通过键 找值
            //prop.get(key)
            String value = prop.getProperty(key);
            System.out.println(key+"==" +value);
        }
    }
}

将集合中内容存储到文件 

package io;

import java.io.FileWriter;
import java.io.IOException;
import java.util.Properties;

//需求：使用Properties集合，完成把集合内容存储到IO流所对应文件中的操作
//分析：
//1，创建Properties集合
//2，添加元素到集合
//3，创建流
//4，把集合中的数据存储到流所对应的文件中
//stroe(Writer,comments)
//store(OutputStream,commonts)
//把集合中的数据，保存到指定的流所对应的文件中，参数commonts代表对描述信息
//5，关闭流
//
//代码演示：
public class PropertiesDemo02 {
    public static void main(String[] args) throws IOException {
        //1，创建Properties集合
        Properties prop = new Properties();
        //2，添加元素到集合
        prop.setProperty("周迅", "张学友");
        prop.setProperty("李小璐", "贾乃亮");
        prop.setProperty("杨幂", "刘恺威");

        //3，创建流
        FileWriter out = new FileWriter("prop.properties");
        //4，把集合中的数据存储到流所对应的文件中
        prop.store(out, "save data");
        //5，关闭流
        out.close();
    }
}



读取文件中的数据，并保存到集合

package io;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;

//需求：从属性集文件prop.properties 中取出数据，保存到集合中
//        分析：
//        1，创建集合
//        2，创建流对象
//        3,把流所对应文件中的数据 读取到集合中
//        load(InputStream)  把指定流所对应的文件中的数据，读取出来，保存到Propertie集合中
//        load(Reader)
//        4,关闭流
//        5,显示集合中的数据
//        代码演示：
public class PropertiesDemo03 {
    public static void main(String[] args) throws IOException {
        //1，创建集合
        Properties prop = new Properties();
        //2，创建流对象
        FileInputStream in = new FileInputStream("prop.properties");
//FileReader in = new FileReader("prop.properties");
        //3,把流所对应文件中的数据 读取到集合中
        prop.load(in);
        //4,关闭流
        in.close();
        //5,显示集合中的数据
        System.out.println(prop);

    }
}

注意：使用字符流FileReader就可以完成文件中的中文读取操作了。

序列化流与反序列化流 
用于从流中读取对象的操作流 ObjectInputStream 称为 反序列化流；用于向流中写入对象的操作流 ObjectOutputStream 称为 序列化流

特点：用于操作对象。可以将对象写入到文件中，也可以从文件中读取对象。

对象序列化流ObjectOutputStream
ObjectOutputStream 将 Java 对象的基本数据类型和图形写入 OutputStream。可以使用 ObjectInputStream 读取（重构）对象。通过在流中使用文件可以实现对象的持久存储。

只能将支持 java.io.Serializable 接口的对象写入流中
代码演示：


package io;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;

public class ObjectStreamDemo {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        /*
         * 将一个对象存储到持久化(硬盘)的设备上。
         */
        writeObj();//对象的序列化。
    }
    public static void writeObj() throws IOException {
        //1,明确存储对象的文件。
        FileOutputStream fos = new FileOutputStream("obj.object");
        //2，给操作文件对象加入写入对象功能。
        ObjectOutputStream oos = new ObjectOutputStream(fos);
        //3，调用了写入对象的方法。
        oos.writeObject(new Person("wangcai",20));
        //关闭资源。
        oos.close();
    }
}

Person类


package io;

import java.io.Serializable;

public class Person implements Serializable {
    private String name;
    private int age;
    public Person() {
        super();
    }
    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    @Override
    public String toString() {
        return "Person [name=" + name + ", age=" + age + "]";
    }
}

对象反序列化流ObjectInputStream
 ObjectInputStream 对以前使用 ObjectOutputStream 写入的基本数据和对象进行反序列化。支持 java.io.Serializable接口的对象才能从流读取。

 代码演示：


package io;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;

public class ObjectStreamDemo1 {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        readObj();//对象的反序列化。
    }
    public static void readObj() throws IOException, ClassNotFoundException {
        //1,定义流对象关联存储了对象文件。
        FileInputStream fis = new FileInputStream("obj.object");
        //2,建立用于读取对象的功能对象。
        ObjectInputStream ois = new ObjectInputStream(fis);
        Person obj = (Person)ois.readObject();
        System.out.println(obj.toString());
    }
}

序列化接口 
当一个对象要能被序列化，这个对象所属的类必须实现Serializable接口。否则会发生异常NotSerializableException异常。
同时当反序列化对象时，如果对象所属的class文件在序列化之后进行的修改，那么进行反序列化也会发生异常InvalidClassException。发生这个异常的原因如下：

该类的序列版本号与从流中读取的类描述符的版本号不匹配
该类包含未知数据类型
该类没有可访问的无参数构造方法
Serializable标记接口。该接口给需要序列化的类，提供了一个序列版本号。serialVersionUID. 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。

代码修改如下，修改后再次写入对象，读取对象测试。 


public class Person implements Serializable {
    //给类显示声明一个序列版本号。
    private static final long serialVersionUID = 1L;
    private String name;
    private int age;
    public Person() {
        super();
        
    }
    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    @Override
    public String toString() {
        return "Person [name=" + name + ", age=" + age + "]";
    }
}

瞬态关键字transient 
当一个类的对象需要被序列化时，某些属性不需要被序列化，这时不需要序列化的属性可以使用关键字transient修饰。只要被transient修饰了，序列化时这个属性就不会被序列化了。
同时静态修饰也不会被序列化，因为序列化是把对象数据进行持久化存储，而静态的属于类加载时的数据，不会被序列化。
代码修改如下，修改后再次写入对象，读取对象测试。


public class Person implements Serializable {
    /*
     * 给类显示声明一个序列版本号。
     */
    private static final long serialVersionUID = 1L;
    private static String name;
    private transient/*瞬态*/ int age;
    
    public Person() {
        super();
        
    }
    
    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person [name=" + name + ", age=" + age + "]";
    }
}

打印流
打印流添加输出数据的功能，使它们能够方便地打印各种数据值表示形式.

打印流根据流的分类：

字节打印流 PrintStream
字符打印流 PrintWriter
方法：

void print(String str): 输出任意类型的数据，
void println(String str): 输出任意类型的数据，自动写入换行操作

package io;

import java.io.IOException;
import java.io.PrintWriter;

/*
* 需求：把指定的数据，写入到printFile.txt文件中
*
* 分析：
*     1，创建流
*     2，写数据
*     3，关闭流
*/
public class PrintWriterDemo {
    public static void main(String[] args) throws IOException {
        //创建流
        //PrintWriter out = new PrintWriter(new FileWriter("printFile.txt"));
        PrintWriter out = new PrintWriter("printFile.txt");
        //2，写数据
        for (int i=0; i<5; i++) {
            out.println("helloWorld");
        }
        //3,关闭流
        out.close();
    }
}

打印流完成数据自动刷新
可以通过构造方法，完成文件数据的自动刷新功能

构造方法：开启文件自动刷新写入功能

public PrintWriter(OutputStream out, boolean autoFlush)
public PrintWriter(Writer out, boolean autoFlush)

package io;

import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

/*
 * 分析：
 *     1，创建流
 *     2，写数据
 */
public class PrintWriterDemo2 {
    public static void main(String[] args) throws IOException {
        //创建流
        PrintWriter out = new PrintWriter(new FileWriter("printFile.txt"), true);
        //2，写数据
        for (int i=0; i<5; i++) {
            out.println("helloWorld");
        }
        //3,关闭流
        out.close();
    }
}

commons-IO
1、导入classpath

加入classpath的第三方jar包内的class文件才能在项目中使用
创建lib文件夹
将commons-io.jar拷贝到lib文件夹
导入jar包
2、FilenameUtils
这个工具类是用来处理文件名（译者注：包含文件路径）的，他可以轻松解决不同操作系统文件名称规范不同的问题
常用方法：

getExtension(String path)：获取文件的扩展名；
getName()：获取文件名；
isExtension(String fileName,String ext)：判断fileName是否是ext后缀名；
3、FileUtils
提供文件操作（移动文件，读取文件，检查文件是否存在等等）的方法。
常用方法：

readFileToString(File file)：读取文件内容，并返回一个String；
writeStringToFile(File file，String content)：将内容content写入到file中；
copyDirectoryToDirectory(File srcDir,File destDir);文件夹复制
copyFile(File srcFile,File destFile);文件夹复制
代码演示：


package io;

import org.apache.commons.io.FileUtils;

import java.io.*;

/*
 * 完成文件的复制
 */
public class CommonsIODemo01 {
    public static void main(String[] args) throws IOException {
        //method1("D:\\test.avi", "D:\\copy.avi");
        //通过Commons-IO完成了文件复制的功能
        FileUtils.copyFile(new File("D:\\test.avi"), new File("D:\\copy.avi"));

        //通过Commons-IO完成了文件夹复制的功能
        //D:\java 复制到 C:\\abc文件夹下
        FileUtils.copyDirectoryToDirectory(new File("D:\\java"), new File("C:\\abc"));
    }
}